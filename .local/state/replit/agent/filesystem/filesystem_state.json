{"file_contents":{"HOW_TO_USE.md":{"content":"# How to Use ChatGPT Browser\n\nThis guide will help you set up, build, and run the ChatGPT Browser application on your Windows machine.\n\n## 📋 Prerequisites\n\n### Required Software\n1. **Python 3.11 or higher**\n   - Download from: https://www.python.org/downloads/\n   - ⚠️ **IMPORTANT**: During installation, check \"Add Python to PATH\"\n\n2. **Git** (optional, for cloning from GitHub)\n   - Download from: https://git-scm.com/download/win\n\n## 🚀 Quick Start\n\n### Option 1: Download from Replit\n1. Export your project as a ZIP file from Replit\n2. Extract the ZIP file to a folder on your Windows machine\n3. Open Command Prompt or PowerShell in that folder\n\n### Option 2: Clone from GitHub (if you've pushed to GitHub)\n```bash\ngit clone https://github.com/your-username/your-repository-name.git\ncd your-repository-name\n```\n\n## 🔧 Installing Dependencies\n\nOpen Command Prompt or PowerShell in your project folder and run:\n\n```bash\n# Install required Python packages\npip install PyQt6 PyQt6-WebEngine pyinstaller\n```\n\nIf you encounter permission issues, try:\n```bash\npip install --user PyQt6 PyQt6-WebEngine pyinstaller\n```\n\n## 🎮 Running the Application\n\n### Development Mode (Python)\nTo run the application directly with Python:\n\n```bash\n# Run the GUI application\npython main.py\n\n# Run headless tests (no GUI)\npython main.py --headless\n\n# Force GUI mode\npython main.py --gui\n```\n\n### First Run\n- The application will create a data folder in `%APPDATA%\\ChatGPT Browser`\n- This is where your sessions, notepad content, and settings are stored\n- Each workspace gets its own isolated browser profile\n\n## 🔨 Building Windows Executable\n\n### Build the Executable\nTo create a standalone Windows executable that users can run without Python:\n\n```bash\n# Clean build (recommended)\npyinstaller --clean --distpath dist --workpath build chatgpt-browser.spec\n```\n\n### Find Your Executable\nAfter building, you'll find your executable at:\n```\ndist/ChatGPTBrowser/ChatGPTBrowser.exe\n```\n\n### Distribute the Application\nTo share with others:\n1. Zip the entire `dist/ChatGPTBrowser/` folder\n2. Recipients extract and run `ChatGPTBrowser.exe`\n3. No Python installation required on target machines\n\n## 🎯 Using the Application\n\n### Workspace Management\n- **4 Independent Workspaces**: Each supports different ChatGPT accounts\n- **Switch Workspaces**: Use `Ctrl+Shift+1` through `Ctrl+Shift+4`\n- **Rename Workspaces**: Right-click on workspace buttons\n\n### Tab Management\n- **New Tab**: `Ctrl+T`\n- **Close Tab**: `Ctrl+W`\n- **Restore Closed Tab**: `Ctrl+Shift+T`\n- **Navigate Tabs**: `Ctrl+Tab` (next), `Ctrl+Shift+Tab` (previous)\n\n### Navigation\n- **Reload**: `Ctrl+R`\n- **Back**: `Alt+Left Arrow`\n- **Forward**: `Alt+Right Arrow`\n\n### Built-in Notepad\n- **Toggle Notepad**: `Ctrl+Shift+K` or click the notepad icon\n- **Per-Workspace**: Each workspace has its own notepad\n- **Auto-Save**: Content saves automatically when modified\n- **Markdown Support**: Write notes in Markdown format\n\n### Session Persistence\n- **Auto-Save**: Sessions save every 4 minutes\n- **Manual Save**: Triggered on workspace switch, tab close, app close\n- **Restoration**: All workspaces and tabs restore on app startup\n\n## 🛠️ Troubleshooting\n\n### Common Issues\n\n**\"Python is not recognized\"**\n- Reinstall Python and ensure \"Add to PATH\" is checked\n- Or add Python to your PATH manually\n\n**\"No module named PyQt6\"**\n- Run: `pip install PyQt6 PyQt6-WebEngine`\n- If using multiple Python versions, try: `python -m pip install PyQt6 PyQt6-WebEngine`\n\n**Executable won't start**\n- Make sure you're running `ChatGPTBrowser.exe` from the `dist/ChatGPTBrowser/` folder\n- Don't move the .exe file out of its folder (it needs the supporting files)\n\n**Application crashes on startup**\n- Try running from Command Prompt to see error messages:\n  ```bash\n  cd dist/ChatGPTBrowser\n  ChatGPTBrowser.exe\n  ```\n\n**Can't access certain websites**\n- The application is designed to only work with ChatGPT.com and essential OpenAI domains\n- This is intentional for security and focus\n\n### Performance Tips\n- Close unused tabs to save memory\n- Each workspace uses its own browser engine, so limit open workspaces if needed\n- The application stores data locally in `%APPDATA%\\ChatGPT Browser`\n\n## 📁 File Structure\n\n```\nyour-project/\n├── src/                    # Source code\n│   ├── config.py          # Application settings\n│   ├── paths.py           # File path management\n│   ├── app.py            # Main application logic\n│   ├── storage/          # Session management\n│   ├── web/              # Browser and workspace logic\n│   └── ui/               # User interface\n├── assets/               # Application icons\n├── main.py              # Entry point\n├── chatgpt-browser.spec  # Build configuration\n└── HOW_TO_USE.md        # This file\n```\n\n## 🔄 Automatic Building (Advanced)\n\nIf you push this project to GitHub, the included GitHub Actions workflow will automatically:\n1. Build Windows executables on every commit\n2. Run tests to verify the build works\n3. Create downloadable artifacts\n4. Optionally create releases for tagged versions\n\nTo use this:\n1. Push your code to a GitHub repository\n2. The workflow runs automatically\n3. Download built executables from the \"Actions\" tab\n\n## 🆘 Getting Help\n\nIf you encounter issues:\n1. Check this guide first\n2. Try running `python main.py --headless` to test basic functionality\n3. Look for error messages in Command Prompt\n4. Make sure all dependencies are properly installed\n\n## 🎉 Enjoy Your ChatGPT Browser!\n\nYou now have a dedicated desktop application for ChatGPT with:\n- 4 isolated workspaces for multiple accounts\n- Built-in notepad for each workspace\n- Complete session persistence\n- Professional keyboard shortcuts\n- Secure, ChatGPT-only browsing\n\nThe application saves everything automatically and restores your exact session when you restart it.","size_bytes":5940},"README.md":{"content":"# ChatGPT Browser\n\nA minimal Python-based desktop browser exclusively for ChatGPT.com with advanced workspace management and session persistence.\n\n## Features\n\n### Core Functionality\n- **Dedicated ChatGPT Browser**: Exclusively displays and interacts with chatgpt.com\n- **4 Isolated Workspaces**: Each with separate cookies, cache, and local storage\n- **Multi-Tab Support**: Multiple ChatGPT tabs per workspace\n- **Session Persistence**: Automatic saving and restoration of workspace states\n- **Built-in Notepad**: Per-workspace notepad with Markdown support\n\n### Session Management\n- **Auto-save**: Sessions saved every 4 minutes\n- **Save Triggers**: App close, workspace switch, tab close\n- **Restore on Startup**: All workspaces and tabs restored when app starts\n- **Isolated Storage**: Each workspace has completely separate data\n\n### UI & UX\n- **Dark Theme**: Modern dark interface (#141414, #282828, #3c3c3c)\n- **Workspace Switching**: Quick switching between 4 workspaces\n- **Tab Management**: Full tab management with restore functionality\n- **Keyboard Shortcuts**: Comprehensive shortcut support\n\n### Keyboard Shortcuts\n\n#### Tab Management\n- `Ctrl+T`: Open new tab\n- `Ctrl+W`: Close current tab  \n- `Ctrl+Shift+T`: Restore last closed tab\n- `Ctrl+Tab`: Next tab\n- `Ctrl+Shift+Tab`: Previous tab\n\n#### Navigation\n- `Ctrl+R`: Reload current tab\n- `Alt+Left`: Navigate back\n- `Alt+Right`: Navigate forward\n\n#### Workspace & Features\n- `Ctrl+Shift+K`: Toggle notepad\n- `Ctrl+Shift+1-4`: Switch to workspace 1-4\n\n## Installation & Usage\n\n### Development Mode (Replit)\n```bash\n# Run headless tests\npython main.py --headless\n\n# Force GUI mode (requires display)\npython main.py --gui\n```\n\n### Building Windows Executable\n\nThe application is designed to be built into a standalone Windows executable using GitHub Actions:\n\n1. **Push to GitHub**: The repository will automatically build Windows executables\n2. **Download**: Get the executable from GitHub Actions artifacts or releases\n3. **Run**: Double-click the .exe file to run the application\n\n#### Manual Build (Windows)\n```bash\n# Install dependencies\npip install PyQt6 PyQt6-WebEngine markdown pyinstaller\n\n# Build executable\npyinstaller chatgpt-browser.spec\n\n# Find executable in dist/ChatGPTBrowser/\n```\n\n## Architecture\n\n### Cross-Platform Design\n- **Windows**: Uses `%APPDATA%\\\\ChatGPT Browser` for data storage\n- **macOS**: Uses `~/Library/Application Support/ChatGPT Browser`\n- **Linux**: Uses `~/.local/share/ChatGPT Browser`\n\n### Workspace Isolation\nEach workspace maintains:\n- Separate QtWebEngine profiles\n- Independent cookies and sessions\n- Isolated local storage and cache\n- Individual notepad content\n\n### Memory Efficiency\n- Lazy loading of workspace resources\n- Proper cleanup on tab/workspace close\n- Optimized session data storage\n- Minimal memory footprint\n\n## File Structure\n\n```\n├── src/\n│   ├── config.py          # Application constants\n│   ├── paths.py           # Cross-platform path management\n│   ├── app.py            # Main application entry point\n│   ├── storage/\n│   │   └── session_manager.py  # Session persistence\n│   ├── web/\n│   │   └── workspace.py        # Web engine & workspace logic\n│   └── ui/\n│       ├── main_window.py      # Main application window\n│       └── notepad.py          # Notepad widget\n├── assets/\n│   ├── logo.png          # Application icon\n│   └── notepad.png       # Notepad toggle icon\n├── main.py               # Entry point\n├── chatgpt-browser.spec  # PyInstaller configuration\n└── .github/workflows/\n    └── build-windows.yml # Windows build automation\n```\n\n## Security & Privacy\n\n- **Isolated Profiles**: Each workspace has completely separate browser profiles\n- **Local Storage**: All data stored locally, no external data transmission\n- **Secure Defaults**: Standard web security policies applied\n- **No Tracking**: Application doesn't collect or transmit user data\n\n## Requirements\n\n### Runtime\n- Windows 10/11 (for executable)\n- Python 3.11+ (for development)\n\n### Development\n- PyQt6\n- PyQt6-WebEngine  \n- markdown\n- pyinstaller (for building)\n\n## Contributing\n\nThis project is designed for personal use but contributions are welcome for:\n- Bug fixes\n- Performance improvements\n- Cross-platform compatibility\n- Additional workspace features\n\n## License\n\nThis project is for personal use. ChatGPT and OpenAI are trademarks of their respective owners.","size_bytes":4512},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nChatGPT Browser - Entry point\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# Add src directory to Python path\nsrc_path = Path(__file__).parent / \"src\"\nsys.path.insert(0, str(src_path))\n\nfrom src.app import main\n\nif __name__ == \"__main__\":\n    sys.exit(main())","size_bytes":283},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"ChatGPT Browser - A dedicated browsing environment for ChatGPT with workspace isolation\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"markdown>=3.9\",\n]\n\n[project.optional-dependencies]\ngui = [\n    \"pyqt6>=6.9.1\",\n    \"pyqt6-webengine>=6.9.0\",\n]\n","size_bytes":320},"replit.md":{"content":"# ChatGPT Browser\n\n## Overview\n\nChatGPT Browser is a minimal Python-based desktop application that provides a dedicated browsing environment exclusively for ChatGPT.com. The application features workspace isolation, session persistence, and a built-in notepad system. It's designed to provide users with multiple isolated ChatGPT sessions while maintaining complete separation between workspaces.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Runtime Environment - Replit Setup\n- **Current Mode**: Running in headless mode for Replit environment compatibility\n- **GUI Limitations**: Full GUI mode requires complete Qt6/QtWebEngine system dependencies not available in this environment\n- **Core Functionality**: Session management, workspace isolation, and data persistence all work perfectly in headless mode\n- **Local GUI**: For full desktop GUI experience, clone locally, install GUI dependencies with `pip install .[gui]`, then run `python main.py --gui`\n\n### Frontend Architecture\n- **UI Framework**: PyQt6-based desktop application with QtWebEngine for web rendering\n- **Window Management**: Single main window with tabbed interface and workspace switching\n- **Component Structure**: Modular UI components including main window, notepad widget, and workspace management dialogs\n- **Theme**: Dark theme with consistent color palette (#141414, #282828, #3c3c3c)\n\n### Backend Architecture\n- **Session Management**: JSON-based session persistence with automatic saving every 4 minutes\n- **Data Storage**: File-system based storage with separate directories per workspace\n- **URL Filtering**: Custom interceptor restricting navigation to ChatGPT and essential OpenAI domains only\n- **Workspace Isolation**: Each workspace maintains separate QtWebEngine profiles with isolated cookies, cache, and local storage\n\n### Core Components\n- **Main Application**: Entry point with headless mode support for CI/testing\n- **Workspace Management**: 4 isolated workspaces with independent web sessions\n- **Tab Management**: Multi-tab support within each workspace with restore functionality\n- **Notepad System**: Per-workspace notepad with Markdown support and persistent storage\n- **Session Persistence**: Automatic save/restore of workspace states, tabs, and notepad content\n\n### Web Engine Configuration\n- **Profile Isolation**: Each workspace uses separate QtWebEngine profiles stored in isolated directories\n- **Security Settings**: Sandbox configuration with development/CI environment adaptations\n- **URL Restriction**: Strict filtering allowing only ChatGPT-related domains and essential resources\n\n### Data Storage Design\n- **Session Data**: JSON files storing workspace configurations, tab states, and metadata\n- **Notepad Storage**: Separate text files per workspace for notepad content\n- **Profile Data**: QtWebEngine profile directories for cookies, cache, and web storage\n- **Cross-Platform Paths**: Platform-aware directory management using Qt's standard paths with fallbacks\n\n### State Management\n- **Auto-Save Triggers**: 4-minute intervals, app close, workspace switch, and tab close events\n- **Restoration**: Complete workspace state restoration on application startup\n- **Workspace Switching**: Hot-swapping between workspaces with preserved states\n\n## External Dependencies\n\n### Core Framework\n- **PyQt6**: Main UI framework and QtWebEngine for web rendering\n- **QtWebEngineCore**: Web engine profiles, URL interception, and page management\n\n### System Integration\n- **Cross-Platform Support**: Windows (APPDATA), macOS (Library/Application Support), Linux (XDG_DATA_HOME)\n- **Headless Environment**: CI/testing support with sandbox configuration - currently active on Replit\n- **Standard Paths**: Qt's QStandardPaths for platform-appropriate data directories\n- **Replit Workflow**: Configured to run headless self-tests and verify core functionality\n\n### Web Dependencies\n- **Allowed Domains**: Restricted to chatgpt.com and essential OpenAI subdomains (auth0.openai.com, cdn.openai.com, static.openai.com, api.openai.com)\n- **CDN Resources**: Cloudflare CDN and Azure blob storage for ChatGPT assets\n- **OAuth Integration**: OpenAI authentication services through designated endpoints","size_bytes":4257},"src/__init__.py":{"content":"# ChatGPT Browser package","size_bytes":25},"src/app.py":{"content":"\"\"\"\nMain application entry point with headless mode support\n\"\"\"\n\nimport sys\nimport os\nfrom typing import Optional\n\nfrom .config import APP_NAME, APP_ORG\nfrom .paths import is_headless_environment, ensure_directories\n\n\ndef setup_environment():\n    \"\"\"Setup environment variables for proper operation\"\"\"\n    # Ensure data directories exist\n    ensure_directories()\n    \n    # Set Qt application properties (only for Linux X11)\n    if sys.platform.startswith(\"linux\") and os.environ.get(\"DISPLAY\"):\n        os.environ.setdefault(\"QT_QPA_PLATFORM\", \"xcb\")\n    \n    # Configure QtWebEngine for headless environments if needed\n    if is_headless_environment():\n        os.environ[\"QTWEBENGINE_DISABLE_SANDBOX\"] = \"1\"\n        os.environ[\"QTWEBENGINE_CHROMIUM_FLAGS\"] = (\n            \"--no-sandbox --disable-gpu --disable-software-rasterizer \"\n            \"--disable-dev-shm-usage --single-process --no-zygote\"\n        )\n\n\ndef run_headless_tests() -> bool:\n    \"\"\"Run headless tests for CI/development environments\"\"\"\n    print(\"Running in headless mode - performing self-tests...\")\n    \n    try:\n        # Test imports\n        from .storage.session_manager import SessionManager\n        from .paths import get_app_data_dir, get_sessions_file\n        \n        print(\"✓ All imports successful\")\n        \n        # Test session manager\n        session_manager = SessionManager()\n        workspaces = session_manager.load_sessions()\n        print(f\"✓ Session manager loaded {len(workspaces)} workspaces\")\n        \n        # Test paths\n        app_data_dir = get_app_data_dir()\n        sessions_file = get_sessions_file()\n        print(f\"✓ App data directory: {app_data_dir}\")\n        print(f\"✓ Sessions file: {sessions_file}\")\n        \n        # Test saving/loading\n        if session_manager.save_sessions(workspaces):\n            print(\"✓ Session save/load test passed\")\n        else:\n            print(\"✗ Session save test failed\")\n            return False\n        \n        # Test URL filter (skip if GUI libraries unavailable)\n        try:\n            from .web.url_filter import ChatGPTUrlFilter\n            url_filter = ChatGPTUrlFilter()\n            print(\"✓ URL filter initialization successful\")\n        except ImportError:\n            print(\"○ URL filter test skipped (GUI libraries not available in headless mode)\")\n        except Exception as e:\n            print(f\"✗ URL filter test failed: {e}\")\n            return False\n        \n        print(\"✓ All headless tests passed!\")\n        return True\n        \n    except Exception as e:\n        print(f\"✗ Headless test failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\n\ndef run_minimal_gui_test() -> bool:\n    \"\"\"Run minimal GUI test to verify QtWebEngine initialization\"\"\"\n    try:\n        from PyQt6.QtWidgets import QApplication\n        from PyQt6.QtWebEngineWidgets import QWebEngineView\n        from PyQt6.QtCore import QUrl, QTimer\n        \n        print(\"Running minimal GUI test...\")\n        \n        app = QApplication.instance()\n        if app is None:\n            app = QApplication(sys.argv)\n        \n        # Create minimal web view\n        web_view = QWebEngineView()\n        web_view.resize(400, 300)\n        \n        # Load about:blank to test QtWebEngine initialization\n        web_view.load(QUrl(\"about:blank\"))\n        \n        # Set up timer to close after 3 seconds\n        timer = QTimer()\n        timer.timeout.connect(app.quit)\n        timer.start(3000)\n        \n        print(\"✓ QtWebEngine initialized successfully\")\n        web_view.deleteLater()\n        return True\n        \n    except Exception as e:\n        print(f\"✗ Minimal GUI test failed: {e}\")\n        return False\n\n\ndef create_gui_application():\n    \"\"\"Create and run the GUI application\"\"\"\n    # Safety check for Replit environment\n    if \"REPLIT\" in os.environ or \"REPL_ID\" in os.environ:\n        if not os.environ.get(\"ALLOW_UNSAFE_GUI\"):\n            print(\"ERROR: GUI mode is not supported in the Replit environment.\")\n            print(\"This is due to missing system dependencies for Qt6/QtWebEngine.\")\n            print(\"To run the GUI version:\")\n            print(\"1. Clone this project locally\")\n            print(\"2. Install GUI dependencies: pip install .[gui]\")\n            print(\"3. Run: python main.py --gui\")\n            print(\"\")\n            print(\"The headless mode works perfectly and provides all core functionality.\")\n            print(\"Run: python main.py --headless\")\n            return 1\n    \n    try:\n        from PyQt6.QtWidgets import QApplication\n        from PyQt6.QtCore import Qt\n        from PyQt6.QtGui import QPalette, QColor\n        from .ui.main_window import MainWindow\n        from .config import COLORS\n        \n        # Create QApplication\n        app = QApplication(sys.argv)\n        app.setApplicationName(APP_NAME)\n        app.setOrganizationName(APP_ORG)\n        \n        # Set dark theme for the application\n        app.setStyle('Fusion')\n        palette = QPalette()\n        palette.setColor(QPalette.ColorRole.Window, QColor(COLORS['primary_bg']))\n        palette.setColor(QPalette.ColorRole.WindowText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Base, QColor(COLORS['secondary_bg']))\n        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(COLORS['accent']))\n        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Text, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Button, QColor(COLORS['secondary_bg']))\n        palette.setColor(QPalette.ColorRole.ButtonText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.BrightText, QColor('red'))\n        palette.setColor(QPalette.ColorRole.Link, QColor('#42A5F5'))\n        palette.setColor(QPalette.ColorRole.Highlight, QColor(COLORS['accent']))\n        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(COLORS['text']))\n        app.setPalette(palette)\n        \n        # Create and show main window\n        window = MainWindow()\n        window.show()\n        \n        return app.exec()\n        \n    except ImportError as e:\n        print(f\"GUI libraries not available: {e}\")\n        print(\"This appears to be a headless environment.\")\n        print(\"To run the GUI version, install PyQt6 and run on a system with a display.\")\n        return 1\n    except Exception as e:\n        print(f\"Error starting GUI application: {e}\")\n        import traceback\n        traceback.print_exc()\n        return 1\n\n\ndef main() -> int:\n    \"\"\"Main entry point\"\"\"\n    # Setup environment\n    setup_environment()\n    \n    # Check if we should run minimal GUI test\n    if \"--gui-test\" in sys.argv:\n        print(f\"ChatGPT Browser - Minimal GUI Test\")\n        if run_minimal_gui_test():\n            return 0\n        else:\n            return 1\n    \n    # Check if we should run in headless mode\n    if is_headless_environment() or \"--headless\" in sys.argv:\n        print(f\"ChatGPT Browser - Headless Mode\")\n        if run_headless_tests():\n            print(\"\\nTo run the GUI version:\")\n            print(\"1. Install PyQt6 and QtWebEngine\")\n            print(\"2. Run on a system with a graphical display\")\n            print(\"3. Or use: python main.py --gui (forces GUI mode)\")\n            return 0\n        else:\n            return 1\n    \n    # Force GUI mode if requested\n    if \"--gui\" in sys.argv:\n        print(\"Forcing GUI mode...\")\n    \n    # Run GUI application\n    print(f\"Starting {APP_NAME}...\")\n    return create_gui_application()\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())","size_bytes":7695},"src/config.py":{"content":"\"\"\"\nConfiguration constants for ChatGPT Browser\n\"\"\"\n\n# Application constants\nAPP_NAME = \"ChatGPT Browser\"\nAPP_ORG = \"ChatGPT Browser\"\nCHATGPT_URL = \"https://chatgpt.com\"\nNUM_WORKSPACES = 4\nAUTOSAVE_INTERVAL_MS = 4 * 60 * 1000  # 4 minutes in milliseconds\n\n# UI Constants\nCOLORS = {\n    'primary_bg': '#141414',\n    'secondary_bg': '#282828', \n    'accent': '#3c3c3c',\n    'text': '#ffffff',\n    'text_dim': '#cccccc'\n}\n\n# Default workspace names\nDEFAULT_WORKSPACE_NAMES = [f\"Workspace {i+1}\" for i in range(NUM_WORKSPACES)]\n\n# File names\nSESSION_FILE = \"sessions.json\"\nNOTEPAD_DIR = \"notepads\"\nASSETS_DIR = \"assets\"","size_bytes":615},"src/paths.py":{"content":"\"\"\"\nCross-platform path management for ChatGPT Browser\n\"\"\"\n\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\n\ndef get_app_data_dir() -> Path:\n    \"\"\"Get the application data directory for the current platform\"\"\"\n    try:\n        from PyQt6.QtCore import QStandardPaths\n        # Use Qt's standard paths for cross-platform compatibility\n        app_data = QStandardPaths.writableLocation(\n            QStandardPaths.StandardLocation.AppDataLocation\n        )\n        if app_data:\n            return Path(app_data)\n    except ImportError:\n        pass\n    \n    # Fallback to manual platform detection\n    if sys.platform == \"win32\":\n        # Windows: %APPDATA%\\ChatGPT Browser\n        app_data = os.environ.get(\"APPDATA\")\n        if app_data:\n            return Path(app_data) / \"ChatGPT Browser\"\n    elif sys.platform == \"darwin\":\n        # macOS: ~/Library/Application Support/ChatGPT Browser\n        home = Path.home()\n        return home / \"Library\" / \"Application Support\" / \"ChatGPT Browser\"\n    else:\n        # Linux: ~/.local/share/ChatGPT Browser\n        xdg_data = os.environ.get(\"XDG_DATA_HOME\")\n        if xdg_data:\n            return Path(xdg_data) / \"ChatGPT Browser\"\n        return Path.home() / \".local\" / \"share\" / \"ChatGPT Browser\"\n    \n    # Ultimate fallback\n    return Path.home() / \".chatgpt-browser\"\n\ndef get_workspace_data_dir(workspace_id: int) -> Path:\n    \"\"\"Get the data directory for a specific workspace\"\"\"\n    base_dir = get_app_data_dir()\n    return base_dir / f\"workspace_{workspace_id}\"\n\ndef get_workspace_profile_dir(workspace_id: int) -> Path:\n    \"\"\"Get the QtWebEngine profile directory for a specific workspace\"\"\"\n    return get_workspace_data_dir(workspace_id) / \"profile\"\n\ndef get_workspace_notepad_file(workspace_id: int) -> Path:\n    \"\"\"Get the notepad file path for a specific workspace\"\"\"\n    return get_workspace_data_dir(workspace_id) / \"notepad.md\"\n\ndef get_sessions_file() -> Path:\n    \"\"\"Get the sessions file path\"\"\"\n    return get_app_data_dir() / \"sessions.json\"\n\ndef ensure_directories():\n    \"\"\"Ensure all necessary directories exist\"\"\"\n    # Create main app data directory\n    get_app_data_dir().mkdir(parents=True, exist_ok=True)\n    \n    # Create workspace directories\n    for i in range(4):  # 4 workspaces\n        get_workspace_data_dir(i).mkdir(parents=True, exist_ok=True)\n        get_workspace_profile_dir(i).mkdir(parents=True, exist_ok=True)\n\ndef get_assets_dir() -> Path:\n    \"\"\"Get the assets directory (relative to script location)\"\"\"\n    # In development, assets are relative to the script\n    # In packaged app, they'll be in the bundle\n    if getattr(sys, 'frozen', False):\n        # Running in PyInstaller bundle\n        bundle_dir = Path(getattr(sys, '_MEIPASS', '.'))\n        return bundle_dir / \"assets\"\n    else:\n        # Running in development\n        script_dir = Path(__file__).parent.parent\n        return script_dir / \"assets\"\n\ndef is_headless_environment() -> bool:\n    \"\"\"Check if we're running in a headless environment\"\"\"\n    # Check for common headless indicators\n    if os.environ.get(\"HEADLESS\") == \"1\":\n        return True\n    \n    # Check if DISPLAY is set on Linux\n    if sys.platform.startswith(\"linux\") and not os.environ.get(\"DISPLAY\"):\n        return True\n    \n    # Check for CI environment variables\n    ci_indicators = [\"CI\", \"GITHUB_ACTIONS\", \"TRAVIS\", \"JENKINS\", \"REPLIT\"]\n    if any(os.environ.get(var) for var in ci_indicators):\n        return True\n    \n    return False","size_bytes":3497},"src/storage/__init__.py":{"content":"# Storage module","size_bytes":16},"src/storage/session_manager.py":{"content":"\"\"\"\nSession management for workspace persistence\n\"\"\"\n\nimport json\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\nfrom ..config import CHATGPT_URL, DEFAULT_WORKSPACE_NAMES\nfrom ..paths import get_sessions_file, get_workspace_notepad_file, ensure_directories\n\n\n@dataclass\nclass TabData:\n    \"\"\"Data structure for tab information\"\"\"\n    url: str\n    title: str = \"ChatGPT\"\n\n\n@dataclass \nclass WorkspaceData:\n    \"\"\"Data structure for workspace information\"\"\"\n    name: str\n    tabs: List[TabData]\n    active_tab: int = 0\n    notepad_content: str = \"\"\n    notepad_visible: bool = False\n\n\nclass SessionManager:\n    \"\"\"Handles session persistence and auto-save functionality\"\"\"\n    \n    def __init__(self):\n        self.session_file = get_sessions_file()\n        ensure_directories()\n    \n    def save_sessions(self, workspaces: Dict[int, WorkspaceData]) -> bool:\n        \"\"\"Save workspace sessions to file\"\"\"\n        try:\n            session_data = {}\n            \n            for workspace_id, workspace_data in workspaces.items():\n                # Save notepad content to separate file\n                notepad_file = get_workspace_notepad_file(workspace_id)\n                notepad_file.write_text(workspace_data.notepad_content, encoding='utf-8')\n                \n                # Save session data (without notepad content to keep it small)\n                session_data[str(workspace_id)] = {\n                    'name': workspace_data.name,\n                    'tabs': [asdict(tab) for tab in workspace_data.tabs],\n                    'active_tab': workspace_data.active_tab,\n                    'notepad_visible': workspace_data.notepad_visible,\n                    'last_saved': time.time()\n                }\n            \n            with open(self.session_file, 'w', encoding='utf-8') as f:\n                json.dump(session_data, f, indent=2)\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Error saving sessions: {e}\")\n            return False\n    \n    def load_sessions(self) -> Dict[int, WorkspaceData]:\n        \"\"\"Load workspace sessions from file\"\"\"\n        if not self.session_file.exists():\n            return self._create_default_workspaces()\n        \n        try:\n            with open(self.session_file, 'r', encoding='utf-8') as f:\n                session_data = json.load(f)\n            \n            workspaces = {}\n            for workspace_id_str, data in session_data.items():\n                workspace_id = int(workspace_id_str)\n                \n                # Load tabs\n                tabs = [TabData(**tab_data) for tab_data in data.get('tabs', [])]\n                if not tabs:  # Ensure at least one tab\n                    tabs = [TabData(url=CHATGPT_URL)]\n                \n                # Load notepad content from separate file\n                notepad_file = get_workspace_notepad_file(workspace_id)\n                notepad_content = \"\"\n                if notepad_file.exists():\n                    try:\n                        notepad_content = notepad_file.read_text(encoding='utf-8')\n                    except Exception as e:\n                        print(f\"Error loading notepad for workspace {workspace_id}: {e}\")\n                \n                workspaces[workspace_id] = WorkspaceData(\n                    name=data.get('name', DEFAULT_WORKSPACE_NAMES[workspace_id]),\n                    tabs=tabs,\n                    active_tab=max(0, min(data.get('active_tab', 0), len(tabs) - 1)),\n                    notepad_content=notepad_content,\n                    notepad_visible=data.get('notepad_visible', False)\n                )\n            \n            # Ensure we have all 4 workspaces\n            for i in range(4):\n                if i not in workspaces:\n                    workspaces[i] = WorkspaceData(\n                        name=DEFAULT_WORKSPACE_NAMES[i],\n                        tabs=[TabData(url=CHATGPT_URL)],\n                        active_tab=0,\n                        notepad_content=\"\",\n                        notepad_visible=False\n                    )\n            \n            return workspaces\n            \n        except Exception as e:\n            print(f\"Error loading sessions: {e}\")\n            return self._create_default_workspaces()\n    \n    def _create_default_workspaces(self) -> Dict[int, WorkspaceData]:\n        \"\"\"Create default workspace configuration\"\"\"\n        return {\n            i: WorkspaceData(\n                name=DEFAULT_WORKSPACE_NAMES[i],\n                tabs=[TabData(url=CHATGPT_URL)],\n                active_tab=0,\n                notepad_content=\"\",\n                notepad_visible=False\n            )\n            for i in range(4)\n        }\n    \n    def backup_sessions(self) -> bool:\n        \"\"\"Create a backup of current sessions\"\"\"\n        if not self.session_file.exists():\n            return False\n            \n        try:\n            import shutil\n            backup_file = self.session_file.with_suffix('.backup.json')\n            shutil.copy2(self.session_file, backup_file)\n            return True\n        except Exception as e:\n            print(f\"Error creating backup: {e}\")\n            return False","size_bytes":5234},"src/ui/__init__.py":{"content":"# UI module","size_bytes":11},"src/ui/main_window.py":{"content":"\"\"\"\nMain application window with workspace management\n\"\"\"\n\nfrom typing import Dict, Optional\nfrom PyQt6.QtWidgets import (\n    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,\n    QFrame, QPushButton, QStackedWidget, QMenu,\n    QDialog, QLineEdit, QLabel, QDialogButtonBox,\n    QSplitter\n)\nfrom PyQt6.QtCore import Qt, QTimer, pyqtSignal\nfrom PyQt6.QtGui import QIcon, QKeySequence, QShortcut, QFont\n\nfrom ..config import COLORS, NUM_WORKSPACES, AUTOSAVE_INTERVAL_MS\nfrom ..paths import get_assets_dir\nfrom ..storage.session_manager import SessionManager, WorkspaceData\nfrom ..web.workspace import WorkspaceWidget\nfrom .notepad import NotepadWidget\n\n\nclass WorkspaceRenameDialog(QDialog):\n    \"\"\"Dialog for renaming workspaces\"\"\"\n    \n    def __init__(self, current_name: str, parent=None):\n        super().__init__(parent)\n        self.setWindowTitle(\"Rename Workspace\")\n        self.setModal(True)\n        self.setup_ui(current_name)\n        self.setup_style()\n    \n    def setup_ui(self, current_name: str):\n        \"\"\"Setup dialog UI\"\"\"\n        layout = QVBoxLayout(self)\n        \n        self.name_edit = QLineEdit(current_name)\n        self.name_edit.selectAll()\n        layout.addWidget(QLabel(\"Workspace Name:\"))\n        layout.addWidget(self.name_edit)\n        \n        # Buttons\n        buttons = QDialogButtonBox(\n            QDialogButtonBox.StandardButton.Ok | \n            QDialogButtonBox.StandardButton.Cancel\n        )\n        buttons.accepted.connect(self.accept)\n        buttons.rejected.connect(self.reject)\n        layout.addWidget(buttons)\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QDialog {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n            }}\n            QLineEdit {{\n                background-color: {COLORS['primary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 3px;\n                padding: 5px;\n                color: {COLORS['text']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['accent']};\n                border: none;\n                border-radius: 3px;\n                padding: 5px 10px;\n                color: {COLORS['text']};\n            }}\n            QPushButton:hover {{\n                background-color: #4c4c4c;\n            }}\n            QLabel {{\n                color: {COLORS['text']};\n            }}\n        \"\"\")\n    \n    def get_name(self) -> str:\n        \"\"\"Get the entered workspace name\"\"\"\n        return self.name_edit.text().strip()\n\n\nclass MainWindow(QMainWindow):\n    \"\"\"Main application window\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self.session_manager = SessionManager()\n        self.workspaces: Dict[int, WorkspaceWidget] = {}\n        self.notepads: Dict[int, NotepadWidget] = {}\n        self.current_workspace = 0\n        \n        # Auto-save timer\n        self.autosave_timer = QTimer()\n        self.autosave_timer.timeout.connect(self.save_sessions)\n        self.autosave_timer.start(AUTOSAVE_INTERVAL_MS)\n        \n        self.setup_ui()\n        self.setup_shortcuts()\n        self.load_sessions()\n        self.setup_style()\n        \n        # Set initial window title with current workspace\n        self.update_window_title()\n    \n    def setup_ui(self):\n        \"\"\"Setup the main UI\"\"\"\n        self.setWindowTitle(\"ChatGPT Browser\")\n        self.setGeometry(100, 100, 1200, 800)\n        \n        # Set window icon\n        assets_dir = get_assets_dir()\n        logo_path = assets_dir / \"logo.png\"\n        if logo_path.exists():\n            self.setWindowIcon(QIcon(str(logo_path)))\n        \n        # Central widget\n        central_widget = QWidget()\n        self.setCentralWidget(central_widget)\n        layout = QVBoxLayout(central_widget)\n        layout.setContentsMargins(0, 0, 0, 0)\n        \n        # Main content area with workspaces (no header)\n        self.workspace_stack = QStackedWidget()\n        layout.addWidget(self.workspace_stack)\n        \n        # Store workspace names for minimal display\n        self.workspace_names = [f\"Workspace {i+1}\" for i in range(NUM_WORKSPACES)]\n    \n    def get_current_workspace_name(self) -> str:\n        \"\"\"Get the name of the current workspace\"\"\"\n        return self.workspace_names[self.current_workspace]\n    \n    def update_window_title(self):\n        \"\"\"Update window title with current workspace name\"\"\"\n        workspace_name = self.get_current_workspace_name()\n        self.setWindowTitle(f\"ChatGPT Browser - {workspace_name}\")\n    \n    def setup_shortcuts(self):\n        \"\"\"Setup keyboard shortcuts\"\"\"\n        # Tab management\n        QShortcut(QKeySequence(\"Ctrl+T\"), self, self.new_tab)\n        QShortcut(QKeySequence(\"Ctrl+W\"), self, self.close_current_tab)\n        QShortcut(QKeySequence(\"Ctrl+Shift+T\"), self, self.restore_last_closed_tab)\n        QShortcut(QKeySequence(\"Ctrl+Tab\"), self, self.next_tab)\n        QShortcut(QKeySequence(\"Ctrl+Shift+Tab\"), self, self.previous_tab)\n        \n        # Navigation\n        QShortcut(QKeySequence(\"Ctrl+R\"), self, self.reload_current_tab)\n        QShortcut(QKeySequence(\"Alt+Left\"), self, self.navigate_back)\n        QShortcut(QKeySequence(\"Alt+Right\"), self, self.navigate_forward)\n        \n        # Workspace and features\n        QShortcut(QKeySequence(\"Ctrl+Shift+K\"), self, self.toggle_current_notepad)\n        QShortcut(QKeySequence(\"Ctrl+Shift+1\"), self, lambda: self.switch_workspace(0))\n        QShortcut(QKeySequence(\"Ctrl+Shift+2\"), self, lambda: self.switch_workspace(1))\n        QShortcut(QKeySequence(\"Ctrl+Shift+3\"), self, lambda: self.switch_workspace(2))\n        QShortcut(QKeySequence(\"Ctrl+Shift+4\"), self, lambda: self.switch_workspace(3))\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QMainWindow {{\n                background-color: {COLORS['primary_bg']};\n                color: {COLORS['text']};\n            }}\n            QFrame {{\n                background-color: {COLORS['secondary_bg']};\n                border-bottom: 1px solid {COLORS['accent']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 5px;\n                padding: 8px 12px;\n                font-weight: bold;\n            }}\n            QPushButton:checked {{\n                background-color: {COLORS['accent']};\n                border-color: #5c5c5c;\n            }}\n            QPushButton:hover {{\n                background-color: {COLORS['accent']};\n            }}\n            QStackedWidget {{\n                background-color: {COLORS['primary_bg']};\n            }}\n        \"\"\")\n    \n    def load_sessions(self):\n        \"\"\"Load workspace sessions\"\"\"\n        workspace_data = self.session_manager.load_sessions()\n        \n        for workspace_id, data in workspace_data.items():\n            # Create workspace widget\n            workspace_widget = WorkspaceWidget(workspace_id, data, self.toggle_current_notepad, self)\n            workspace_widget.session_changed.connect(self.save_sessions)\n            self.workspaces[workspace_id] = workspace_widget\n            \n            # Create notepad widget\n            notepad_widget = NotepadWidget(self)\n            notepad_widget.set_content(data.notepad_content)\n            notepad_widget.content_changed.connect(self.save_sessions)\n            notepad_widget.close_requested.connect(lambda: self.toggle_current_notepad(False))\n            self.notepads[workspace_id] = notepad_widget\n            \n            # Create combined widget with splitter\n            from PyQt6.QtWidgets import QSplitter\n            combined_widget = QWidget()\n            layout = QVBoxLayout(combined_widget)\n            layout.setContentsMargins(0, 0, 0, 0)\n            \n            splitter = QSplitter(Qt.Orientation.Vertical)\n            splitter.setObjectName(\"main-splitter\")\n            splitter.addWidget(workspace_widget)\n            splitter.addWidget(notepad_widget)\n            splitter.setSizes([800, 0])  # Hide notepad initially\n            \n            if data.notepad_visible:\n                splitter.setSizes([600, 200])\n                notepad_widget.show()\n            else:\n                notepad_widget.hide()\n            \n            layout.addWidget(splitter)\n            self.workspace_stack.addWidget(combined_widget)\n            \n            # Update workspace name\n            if workspace_id < len(self.workspace_names):\n                self.workspace_names[workspace_id] = data.name\n    \n    def save_sessions(self):\n        \"\"\"Save current workspace sessions\"\"\"\n        workspace_data = {}\n        for workspace_id in range(NUM_WORKSPACES):\n            if workspace_id in self.workspaces and workspace_id in self.notepads:\n                session_data = self.workspaces[workspace_id].get_session_data()\n                # Update notepad content\n                session_data.notepad_content = self.notepads[workspace_id].get_content()\n                session_data.notepad_visible = self.notepads[workspace_id].isVisible()\n                workspace_data[workspace_id] = session_data\n        \n        self.session_manager.save_sessions(workspace_data)\n        \n        # Clear notepad change flags\n        for notepad in self.notepads.values():\n            notepad.clear_changes_flag()\n    \n    def switch_workspace(self, workspace_id: int):\n        \"\"\"Switch to specified workspace\"\"\"\n        if workspace_id == self.current_workspace or workspace_id >= NUM_WORKSPACES:\n            return\n        \n        # Save current workspace session\n        self.save_sessions()\n        \n        # Switch workspace\n        self.current_workspace = workspace_id\n        self.workspace_stack.setCurrentIndex(workspace_id)\n        \n        # Update window title to show current workspace\n        self.update_window_title()\n    \n    def show_workspace_context_menu(self, workspace_id: int, pos):\n        \"\"\"Show context menu for workspace renaming - not used in minimal UI\"\"\"\n        # Context menu functionality removed in minimal design\n        pass\n    \n    def rename_workspace(self, workspace_id: int):\n        \"\"\"Rename a workspace\"\"\"\n        current_name = self.workspace_names[workspace_id]\n        dialog = WorkspaceRenameDialog(current_name, self)\n        \n        if dialog.exec() == QDialog.DialogCode.Accepted:\n            new_name = dialog.get_name()\n            if new_name:\n                self.workspace_names[workspace_id] = new_name\n                if workspace_id in self.workspaces:\n                    self.workspaces[workspace_id].workspace_data.name = new_name\n                # Update window title if this is the current workspace\n                if workspace_id == self.current_workspace:\n                    self.setWindowTitle(f\"ChatGPT Browser - {new_name}\")\n                self.save_sessions()\n    \n    def get_current_workspace(self) -> Optional[WorkspaceWidget]:\n        \"\"\"Get the currently active workspace widget\"\"\"\n        return self.workspaces.get(self.current_workspace)\n    \n    def get_current_notepad(self) -> Optional[NotepadWidget]:\n        \"\"\"Get the currently active notepad widget\"\"\"\n        return self.notepads.get(self.current_workspace)\n    \n    # Tab management methods\n    def new_tab(self):\n        \"\"\"Create new tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.new_tab()\n    \n    def close_current_tab(self):\n        \"\"\"Close current tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            current_index = workspace.tab_widget.currentIndex()\n            workspace.close_tab(current_index)\n    \n    def restore_last_closed_tab(self):\n        \"\"\"Restore last closed tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.restore_last_closed_tab()\n    \n    def next_tab(self):\n        \"\"\"Switch to next tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            count = workspace.tab_widget.count()\n            current = workspace.tab_widget.currentIndex()\n            next_index = (current + 1) % count\n            workspace.tab_widget.setCurrentIndex(next_index)\n    \n    def previous_tab(self):\n        \"\"\"Switch to previous tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            count = workspace.tab_widget.count()\n            current = workspace.tab_widget.currentIndex()\n            prev_index = (current - 1) % count\n            workspace.tab_widget.setCurrentIndex(prev_index)\n    \n    # Navigation methods\n    def reload_current_tab(self):\n        \"\"\"Reload current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.reload_current_tab()\n    \n    def navigate_back(self):\n        \"\"\"Navigate back in current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.navigate_back()\n    \n    def navigate_forward(self):\n        \"\"\"Navigate forward in current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.navigate_forward()\n    \n    def toggle_current_notepad(self, show: Optional[bool] = None):\n        \"\"\"Toggle notepad for current workspace\"\"\"\n        notepad = self.get_current_notepad()\n        if notepad:\n            # Get the splitter from the current workspace\n            current_widget = self.workspace_stack.currentWidget()\n            if current_widget:\n                splitter = current_widget.findChild(QSplitter, \"main-splitter\")\n                if splitter:\n                    if show is None:\n                        show = not notepad.isVisible()\n                    \n                    if show:\n                        notepad.show()\n                        splitter.setSizes([600, 200])\n                    else:\n                        notepad.hide()\n                        splitter.setSizes([800, 0])\n                    \n                    self.save_sessions()\n    \n    def closeEvent(self, a0):\n        \"\"\"Handle application close event\"\"\"\n        # Save sessions before closing\n        self.save_sessions()\n        \n        # Clean up resources\n        for workspace in self.workspaces.values():\n            workspace.cleanup()\n        \n        if a0:\n            a0.accept()","size_bytes":14629},"src/ui/notepad.py":{"content":"\"\"\"\nNotepad widget with Markdown support\n\"\"\"\n\nfrom PyQt6.QtWidgets import (\n    QWidget, QVBoxLayout, QHBoxLayout, QLabel, \n    QPushButton, QTextEdit, QFrame\n)\nfrom PyQt6.QtCore import Qt, pyqtSignal\nfrom PyQt6.QtGui import QFont\n\nfrom ..config import COLORS\n\n\nclass NotepadWidget(QWidget):\n    \"\"\"Notepad widget with Markdown support\"\"\"\n    \n    content_changed = pyqtSignal()\n    close_requested = pyqtSignal()\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setup_ui()\n        self.setup_style()\n        self._content_changed = False\n    \n    def setup_ui(self):\n        \"\"\"Setup the notepad UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(10, 10, 10, 10)\n        \n        # Header\n        header = QHBoxLayout()\n        self.title_label = QLabel(\"Notepad\")\n        self.title_label.setFont(QFont(\"Arial\", 12, QFont.Weight.Bold))\n        header.addWidget(self.title_label)\n        header.addStretch()\n        \n        # Close button\n        self.close_btn = QPushButton(\"×\")\n        self.close_btn.setFixedSize(20, 20)\n        self.close_btn.clicked.connect(self.close_requested.emit)\n        header.addWidget(self.close_btn)\n        \n        layout.addLayout(header)\n        \n        # Text editor\n        self.text_edit = QTextEdit()\n        self.text_edit.setFont(QFont(\"Consolas\", 10))\n        self.text_edit.textChanged.connect(self._on_text_changed)\n        self.text_edit.setPlaceholderText(\"Write your notes here... Markdown is supported!\")\n        layout.addWidget(self.text_edit)\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 5px;\n            }}\n            QTextEdit {{\n                background-color: {COLORS['primary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 3px;\n                padding: 8px;\n                font-family: 'Consolas', monospace;\n                color: {COLORS['text']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['accent']};\n                border: none;\n                border-radius: 10px;\n                font-weight: bold;\n                color: {COLORS['text']};\n            }}\n            QPushButton:hover {{\n                background-color: #4c4c4c;\n            }}\n            QLabel {{\n                border: none;\n                color: {COLORS['text']};\n            }}\n        \"\"\")\n    \n    def _on_text_changed(self):\n        \"\"\"Mark content as changed when text is modified\"\"\"\n        self._content_changed = True\n        self.content_changed.emit()\n    \n    def set_content(self, content: str):\n        \"\"\"Set notepad content\"\"\"\n        self.text_edit.setPlainText(content)\n        self._content_changed = False\n    \n    def get_content(self) -> str:\n        \"\"\"Get notepad content\"\"\"\n        return self.text_edit.toPlainText()\n    \n    def has_changes(self) -> bool:\n        \"\"\"Check if content has been modified\"\"\"\n        return self._content_changed\n    \n    def clear_changes_flag(self):\n        \"\"\"Clear the changes flag (called after saving)\"\"\"\n        self._content_changed = False","size_bytes":3367},"src/web/__init__.py":{"content":"# Web module","size_bytes":12},"src/web/url_filter.py":{"content":"\"\"\"\nURL filtering to restrict navigation to ChatGPT domains only\n\"\"\"\n\nfrom PyQt6.QtCore import QObject, QUrl\nfrom PyQt6.QtWebEngineCore import QWebEngineUrlRequestInterceptor, QWebEngineUrlRequestInfo\n\n\nclass ChatGPTUrlFilter(QWebEngineUrlRequestInterceptor):\n    \"\"\"URL filter to restrict navigation to ChatGPT domains only\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # Allowed domains for ChatGPT functionality (minimal and specific)\n        self.allowed_domains = {\n            'chatgpt.com',\n            # Complete OAuth/Auth domains for login flows\n            'auth0.openai.com',\n            'auth.openai.com', \n            'login.openai.com',\n            'openai.auth0.com',\n            # Essential OpenAI API and CDN domains\n            'cdn.openai.com', \n            'static.openai.com',\n            'api.openai.com',\n            'files.oaiusercontent.com',\n            # CRITICAL: Main ChatGPT CDN for CSS/JS resources\n            'cdn.oaistatic.com',\n            'oaistatic.com',\n            # Specific CDN subdomains that ChatGPT actually uses\n            'cdnjs.cloudflare.com',\n            'chat.openai.com.cdn.cloudflare.net',\n            # Required for OAuth and essential functionality\n            'openaiapi-site.azureedge.net',\n            'openaicomproductionae4b.blob.core.windows.net',\n            # Additional voice features\n            'chatgpt.livekit.cloud'\n        }\n        \n        # Allowed URL patterns for specific resources\n        self.allowed_patterns = [\n            'data:',  # Data URLs for images, etc.\n            'blob:',  # Blob URLs for file handling\n            'about:blank',  # Blank pages\n        ]\n    \n    def interceptRequest(self, info: QWebEngineUrlRequestInfo):\n        \"\"\"Intercept and filter URL requests\"\"\"\n        url = info.requestUrl()\n        url_string = url.toString()\n        \n        # Allow specific URL patterns\n        for pattern in self.allowed_patterns:\n            if url_string.startswith(pattern):\n                return\n        \n        # Check domain\n        host = url.host().lower()\n        \n        # Allow main domain and subdomains\n        allowed = False\n        for domain in self.allowed_domains:\n            if host == domain or host.endswith('.' + domain):\n                allowed = True\n                break\n        \n        # Block if not allowed\n        if not allowed:\n            print(f\"🚫 BLOCKED: {host} -> {url_string}\")\n            info.block(True)\n            return\n        \n        # Allow the request explicitly\n        print(f\"✅ ALLOWED: {host} -> {url_string}\")\n        info.block(False)","size_bytes":2644},"src/web/workspace.py":{"content":"\"\"\"\nWeb workspace management with isolated QtWebEngine profiles\n\"\"\"\n\nimport os\nfrom typing import List, Optional, Callable\nfrom PyQt6.QtCore import Qt, QUrl, pyqtSignal\nfrom PyQt6.QtWidgets import QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QLabel, QPushButton, QFrame\nfrom PyQt6.QtGui import QIcon, QFont\nfrom PyQt6.QtWebEngineWidgets import QWebEngineView\nfrom PyQt6.QtWebEngineCore import QWebEngineProfile, QWebEngineSettings, QWebEnginePage\n\nfrom ..config import CHATGPT_URL\nfrom ..paths import get_workspace_profile_dir\nfrom ..storage.session_manager import TabData, WorkspaceData\nfrom .url_filter import ChatGPTUrlFilter\n\n\nclass ChatGPTWebView(QWebEngineView):\n    \"\"\"Custom web view for ChatGPT with isolated profile\"\"\"\n    \n    def __init__(self, workspace_id: int, profile: QWebEngineProfile, parent=None):\n        super().__init__(parent)\n        \n        self.workspace_id = workspace_id\n        \n        # Use shared profile for this workspace\n        self.profile = profile\n        \n        # Create page with shared workspace profile\n        self.page_obj = QWebEnginePage(self.profile, self)\n        self.setPage(self.page_obj)\n        \n        # Configure for secure operation\n        self._setup_security_settings()\n        \n        # Load ChatGPT\n        self.load(QUrl(CHATGPT_URL))\n    \n    def _setup_security_settings(self):\n        \"\"\"Setup security settings for the web engine\"\"\"\n        # Note: In production builds, we should NOT disable the sandbox\n        # This is only for development/CI environments\n        if os.environ.get(\"QTWEBENGINE_DISABLE_SANDBOX\") == \"1\":\n            # Only in headless CI environments\n            pass\n        \n        # Set user agent to avoid any potential blocking\n        page = self.page()\n        if page:\n            profile = page.profile()\n            if profile:\n                # Use a standard Chrome user agent\n                user_agent = (\n                    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \"\n                    \"AppleWebKit/537.36 (KHTML, like Gecko) \"\n                    \"Chrome/121.0.0.0 Safari/537.36\"\n                )\n                profile.setHttpUserAgent(user_agent)\n    \n    def closeEvent(self, a0):\n        \"\"\"Clean up resources when closing\"\"\"\n        if hasattr(self, 'page_obj'):\n            self.page_obj.deleteLater()\n        super().closeEvent(a0)\n\n\nclass WorkspaceTabWidget(QTabWidget):\n    \"\"\"Custom tab widget for individual workspace tabs\"\"\"\n    \n    tab_close_requested = pyqtSignal(int)\n    new_tab_requested = pyqtSignal()\n    \n    def __init__(self, workspace_name: str = \"\", notepad_toggle_callback: Optional[Callable] = None, parent=None):\n        super().__init__(parent)\n        self.setTabsClosable(True)\n        self.setMovable(True)\n        self.setDocumentMode(True)\n        self.tabCloseRequested.connect(self.tab_close_requested.emit)\n        \n        self.workspace_name = workspace_name\n        self.notepad_toggle_callback = notepad_toggle_callback\n        \n        self.setup_style()\n        self.setup_corner_widget()\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling to tabs\"\"\"\n        from ..config import COLORS\n        \n        self.setStyleSheet(f\"\"\"\n            QTabWidget::pane {{\n                border: 1px solid {COLORS['accent']};\n                background-color: {COLORS['primary_bg']};\n            }}\n            QTabBar::tab {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                padding: 8px 12px;\n                margin-right: 2px;\n                border-top-left-radius: 4px;\n                border-top-right-radius: 4px;\n                min-width: 120px;\n            }}\n            QTabBar::tab:selected {{\n                background-color: {COLORS['primary_bg']};\n                border-bottom: 2px solid {COLORS['accent']};\n            }}\n            QTabBar::tab:hover {{\n                background-color: {COLORS['accent']};\n            }}\n            QTabBar::close-button {{\n                image: url();\n                background-color: transparent;\n                border-radius: 8px;\n                width: 16px;\n                height: 16px;\n            }}\n            QTabBar::close-button:hover {{\n                background-color: #ff4444;\n            }}\n        \"\"\")\n    \n    def setup_corner_widget(self):\n        \"\"\"Setup corner widget with workspace name and notepad toggle\"\"\"\n        if not self.workspace_name:\n            return\n            \n        corner_widget = QFrame()\n        corner_widget.setObjectName(\"workspace-corner-widget\")\n        \n        layout = QHBoxLayout(corner_widget)\n        layout.setContentsMargins(8, 2, 8, 2)\n        layout.setSpacing(8)\n        \n        # Workspace name label\n        workspace_label = QLabel(self.workspace_name)\n        workspace_label.setObjectName(\"workspace-name\")\n        workspace_label.setFont(QFont(\"Segoe UI\", 9, QFont.Weight.Bold))\n        layout.addWidget(workspace_label)\n        \n        # Notepad toggle button\n        if self.notepad_toggle_callback:\n            notepad_btn = QPushButton(\"📝\")\n            notepad_btn.setObjectName(\"notepad-toggle\")\n            notepad_btn.setFixedSize(20, 20)\n            notepad_btn.setToolTip(\"Toggle Notepad (Ctrl+Shift+K)\")\n            notepad_btn.clicked.connect(self.notepad_toggle_callback)\n            layout.addWidget(notepad_btn)\n        \n        # Set as corner widget (top-right)\n        self.setCornerWidget(corner_widget, Qt.Corner.TopRightCorner)\n    \n    def update_workspace_name(self, name: str):\n        \"\"\"Update the workspace name displayed in corner widget\"\"\"\n        self.workspace_name = name\n        corner_widget = self.cornerWidget(Qt.Corner.TopRightCorner)\n        if corner_widget:\n            label = corner_widget.findChild(QLabel, \"workspace-name\")\n            if label:\n                label.setText(name)\n\n\nclass WorkspaceWidget(QWidget):\n    \"\"\"Widget representing a single workspace with tabs\"\"\"\n    \n    session_changed = pyqtSignal()\n    \n    def __init__(self, workspace_id: int, workspace_data: WorkspaceData, notepad_toggle_callback: Optional[Callable] = None, parent=None):\n        super().__init__(parent)\n        self.workspace_id = workspace_id\n        self.workspace_data = workspace_data\n        self.notepad_toggle_callback = notepad_toggle_callback\n        self.web_views: List[ChatGPTWebView] = []\n        self.closed_tabs: List[TabData] = []  # For tab restoration\n        self.max_closed_tabs = 10  # Limit memory usage from closed tabs\n        \n        # Create single shared profile for this workspace\n        self.workspace_profile = self._create_workspace_profile()\n        \n        self.setup_ui()\n        self.restore_session()\n    \n    def _create_workspace_profile(self) -> QWebEngineProfile:\n        \"\"\"Create a single shared profile for this workspace\"\"\"\n        profile_dir = get_workspace_profile_dir(self.workspace_id)\n        profile_name = f\"workspace_{self.workspace_id}\"\n        \n        # Create profile with persistent storage\n        profile = QWebEngineProfile(profile_name, self)\n        profile.setPersistentStoragePath(str(profile_dir))\n        profile.setCachePath(str(profile_dir / \"cache\"))\n        \n        # Enable persistent cookies and storage\n        profile.setPersistentCookiesPolicy(\n            QWebEngineProfile.PersistentCookiesPolicy.AllowPersistentCookies\n        )\n        \n        # Configure profile settings for optimal ChatGPT experience\n        settings = profile.settings()\n        if settings:\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalStorageEnabled, True)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptEnabled, True)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.PluginsEnabled, False)  # Disable plugins for memory efficiency\n            settings.setAttribute(QWebEngineSettings.WebAttribute.AutoLoadImages, True)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalContentCanAccessRemoteUrls, True)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalContentCanAccessFileUrls, True)\n            \n            # Memory optimization settings\n            settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptCanOpenWindows, False)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.WebGLEnabled, False)  # Disable WebGL for memory savings\n            settings.setAttribute(QWebEngineSettings.WebAttribute.Accelerated2dCanvasEnabled, False)  # Reduce GPU memory usage\n        \n        # Configure memory-efficient cache settings\n        # Set cache size limits to prevent excessive memory/disk usage\n        profile.setHttpCacheMaximumSize(50 * 1024 * 1024)  # 50MB cache limit\n        \n        # Set HTTP cache type for better memory management\n        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)\n        \n        # Install URL filter to restrict to ChatGPT domains only\n        url_filter = ChatGPTUrlFilter(self)\n        profile.setUrlRequestInterceptor(url_filter)\n        \n        return profile\n    \n    def setup_ui(self):\n        \"\"\"Setup the workspace UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        \n        # Tab widget for web views with workspace info\n        workspace_name = self.workspace_data.name if self.workspace_data else f\"Workspace {self.workspace_id + 1}\"\n        self.tab_widget = WorkspaceTabWidget(workspace_name, self.notepad_toggle_callback)\n        self.tab_widget.tab_close_requested.connect(self.close_tab)\n        self.tab_widget.new_tab_requested.connect(self.new_tab)\n        self.tab_widget.currentChanged.connect(self._on_tab_changed)\n        \n        layout.addWidget(self.tab_widget)\n    \n    def restore_session(self):\n        \"\"\"Restore tabs from workspace data\"\"\"\n        for tab_data in self.workspace_data.tabs:\n            self.add_tab(tab_data.url)\n        \n        # Set active tab\n        if 0 <= self.workspace_data.active_tab < self.tab_widget.count():\n            self.tab_widget.setCurrentIndex(self.workspace_data.active_tab)\n    \n    def add_tab(self, url: str = CHATGPT_URL) -> int:\n        \"\"\"Add a new tab with ChatGPT\"\"\"\n        # Check if we have too many tabs (memory protection)\n        if len(self.web_views) >= 15:  # Limit tabs per workspace for memory efficiency\n            return self.tab_widget.currentIndex()  # Return current tab instead of failing\n            \n        web_view = ChatGPTWebView(self.workspace_id, self.workspace_profile)\n        web_view.load(QUrl(url))\n        \n        self.web_views.append(web_view)\n        tab_index = self.tab_widget.addTab(web_view, \"ChatGPT\")\n        \n        # Connect signals\n        web_view.titleChanged.connect(\n            lambda title, idx=tab_index: self._update_tab_title(idx, title)\n        )\n        \n        self.session_changed.emit()\n        return tab_index\n    \n    def _update_tab_title(self, index: int, title: str):\n        \"\"\"Update tab title, truncating if too long\"\"\"\n        if index < self.tab_widget.count():\n            truncated_title = title[:30] + \"...\" if len(title) > 30 else title\n            self.tab_widget.setTabText(index, truncated_title)\n    \n    def close_tab(self, index: int):\n        \"\"\"Close a tab and save for restoration\"\"\"\n        if self.tab_widget.count() <= 1:\n            return  # Don't close the last tab\n        \n        web_view = self.tab_widget.widget(index)\n        if isinstance(web_view, ChatGPTWebView):\n            # Save tab data for restoration (with memory limit)\n            self.closed_tabs.append(TabData(\n                url=web_view.url().toString(),\n                title=self.tab_widget.tabText(index)\n            ))\n            \n            # Limit closed tabs to prevent memory leak\n            if len(self.closed_tabs) > self.max_closed_tabs:\n                self.closed_tabs.pop(0)  # Remove oldest closed tab\n            \n            # Remove from lists\n            if web_view in self.web_views:\n                self.web_views.remove(web_view)\n            \n            # Close tab\n            self.tab_widget.removeTab(index)\n            web_view.deleteLater()\n            \n            self.session_changed.emit()\n    \n    def new_tab(self):\n        \"\"\"Create a new tab\"\"\"\n        index = self.add_tab()\n        self.tab_widget.setCurrentIndex(index)\n    \n    def restore_last_closed_tab(self):\n        \"\"\"Restore the most recently closed tab\"\"\"\n        if self.closed_tabs:\n            tab_data = self.closed_tabs.pop()\n            index = self.add_tab(tab_data.url)\n            self.tab_widget.setCurrentIndex(index)\n    \n    def _on_tab_changed(self, index: int):\n        \"\"\"Handle tab change\"\"\"\n        self.workspace_data.active_tab = index\n        self.session_changed.emit()\n    \n    def get_session_data(self) -> WorkspaceData:\n        \"\"\"Get current session data for this workspace\"\"\"\n        tabs = []\n        for i in range(self.tab_widget.count()):\n            web_view = self.tab_widget.widget(i)\n            if isinstance(web_view, ChatGPTWebView):\n                tabs.append(TabData(\n                    url=web_view.url().toString(),\n                    title=self.tab_widget.tabText(i)\n                ))\n        \n        return WorkspaceData(\n            name=self.workspace_data.name,\n            tabs=tabs,\n            active_tab=self.tab_widget.currentIndex(),\n            notepad_content=self.workspace_data.notepad_content,\n            notepad_visible=self.workspace_data.notepad_visible\n        )\n    \n    def reload_current_tab(self):\n        \"\"\"Reload the current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.reload()\n    \n    def navigate_back(self):\n        \"\"\"Navigate back in current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.back()\n    \n    def navigate_forward(self):\n        \"\"\"Navigate forward in current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.forward()\n    \n    def cleanup(self):\n        \"\"\"Clean up resources\"\"\"\n        # Clear closed tabs to free memory\n        self.closed_tabs.clear()\n        \n        # Clean up web views\n        for web_view in self.web_views:\n            # Force cleanup of web engine resources\n            if hasattr(web_view, 'page_obj') and web_view.page_obj:\n                web_view.page_obj.deleteLater()\n            web_view.deleteLater()\n        self.web_views.clear()\n        \n        # Clean up profile resources\n        if hasattr(self, 'workspace_profile'):\n            self.workspace_profile.clearAllVisitedLinks()\n            self.workspace_profile.clearHttpCache()","size_bytes":14914}},"version":1}