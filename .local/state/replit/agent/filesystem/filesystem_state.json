{"file_contents":{"HOW_TO_USE.md":{"content":"# How to Use ChatGPT Browser\n\nThis guide will help you set up, build, and run the ChatGPT Browser application on your Windows machine.\n\n## 📋 Prerequisites\n\n### Required Software\n1. **Python 3.11 or higher**\n   - Download from: https://www.python.org/downloads/\n   - ⚠️ **IMPORTANT**: During installation, check \"Add Python to PATH\"\n\n2. **Git** (optional, for cloning from GitHub)\n   - Download from: https://git-scm.com/download/win\n\n## 🚀 Quick Start\n\n### Option 1: Download from Replit\n1. Export your project as a ZIP file from Replit\n2. Extract the ZIP file to a folder on your Windows machine\n3. Open Command Prompt or PowerShell in that folder\n\n### Option 2: Clone from GitHub (if you've pushed to GitHub)\n```bash\ngit clone https://github.com/your-username/your-repository-name.git\ncd your-repository-name\n```\n\n## 🔧 Installing Dependencies\n\nOpen Command Prompt or PowerShell in your project folder and run:\n\n```bash\n# Install required Python packages\npip install PyQt6 PyQt6-WebEngine pyinstaller\n```\n\nIf you encounter permission issues, try:\n```bash\npip install --user PyQt6 PyQt6-WebEngine pyinstaller\n```\n\n## 🎮 Running the Application\n\n### Development Mode (Python)\nTo run the application directly with Python:\n\n```bash\n# Run the GUI application\npython main.py\n\n# Run headless tests (no GUI)\npython main.py --headless\n\n# Force GUI mode\npython main.py --gui\n```\n\n### First Run\n- The application will create a data folder in `%APPDATA%\\ChatGPT Browser`\n- This is where your sessions, notepad content, and settings are stored\n- Each workspace gets its own isolated browser profile\n\n## 🔨 Building Windows Executable\n\n### Build the Executable\nTo create a standalone Windows executable that users can run without Python:\n\n```bash\n# Clean build (recommended)\npyinstaller --clean --distpath dist --workpath build chatgpt-browser.spec\n```\n\n### Find Your Executable\nAfter building, you'll find your executable at:\n```\ndist/ChatGPTBrowser/ChatGPTBrowser.exe\n```\n\n### Distribute the Application\nTo share with others:\n1. Zip the entire `dist/ChatGPTBrowser/` folder\n2. Recipients extract and run `ChatGPTBrowser.exe`\n3. No Python installation required on target machines\n\n## 🎯 Using the Application\n\n### Workspace Management\n- **4 Independent Workspaces**: Each supports different ChatGPT accounts\n- **Switch Workspaces**: Use `Ctrl+Shift+1` through `Ctrl+Shift+4`\n- **Rename Workspaces**: Right-click on workspace buttons\n\n### Tab Management\n- **New Tab**: `Ctrl+T`\n- **Close Tab**: `Ctrl+W`\n- **Restore Closed Tab**: `Ctrl+Shift+T`\n- **Navigate Tabs**: `Ctrl+Tab` (next), `Ctrl+Shift+Tab` (previous)\n\n### Navigation\n- **Reload**: `Ctrl+R`\n- **Back**: `Alt+Left Arrow`\n- **Forward**: `Alt+Right Arrow`\n\n### Built-in Notepad\n- **Toggle Notepad**: `Ctrl+Shift+K` or click the notepad icon\n- **Per-Workspace**: Each workspace has its own notepad\n- **Auto-Save**: Content saves automatically when modified\n- **Markdown Support**: Write notes in Markdown format\n\n### Session Persistence\n- **Auto-Save**: Sessions save every 4 minutes\n- **Manual Save**: Triggered on workspace switch, tab close, app close\n- **Restoration**: All workspaces and tabs restore on app startup\n\n## 🛠️ Troubleshooting\n\n### Common Issues\n\n**\"Python is not recognized\"**\n- Reinstall Python and ensure \"Add to PATH\" is checked\n- Or add Python to your PATH manually\n\n**\"No module named PyQt6\"**\n- Run: `pip install PyQt6 PyQt6-WebEngine`\n- If using multiple Python versions, try: `python -m pip install PyQt6 PyQt6-WebEngine`\n\n**Executable won't start**\n- Make sure you're running `ChatGPTBrowser.exe` from the `dist/ChatGPTBrowser/` folder\n- Don't move the .exe file out of its folder (it needs the supporting files)\n\n**Application crashes on startup**\n- Try running from Command Prompt to see error messages:\n  ```bash\n  cd dist/ChatGPTBrowser\n  ChatGPTBrowser.exe\n  ```\n\n**Can't access certain websites**\n- The application is designed to only work with ChatGPT.com and essential OpenAI domains\n- This is intentional for security and focus\n\n### Performance Tips\n- Close unused tabs to save memory\n- Each workspace uses its own browser engine, so limit open workspaces if needed\n- The application stores data locally in `%APPDATA%\\ChatGPT Browser`\n\n## 📁 File Structure\n\n```\nyour-project/\n├── src/                    # Source code\n│   ├── config.py          # Application settings\n│   ├── paths.py           # File path management\n│   ├── app.py            # Main application logic\n│   ├── storage/          # Session management\n│   ├── web/              # Browser and workspace logic\n│   └── ui/               # User interface\n├── assets/               # Application icons\n├── main.py              # Entry point\n├── chatgpt-browser.spec  # Build configuration\n└── HOW_TO_USE.md        # This file\n```\n\n## 🔄 Automatic Building (Advanced)\n\nIf you push this project to GitHub, the included GitHub Actions workflow will automatically:\n1. Build Windows executables on every commit\n2. Run tests to verify the build works\n3. Create downloadable artifacts\n4. Optionally create releases for tagged versions\n\nTo use this:\n1. Push your code to a GitHub repository\n2. The workflow runs automatically\n3. Download built executables from the \"Actions\" tab\n\n## 🆘 Getting Help\n\nIf you encounter issues:\n1. Check this guide first\n2. Try running `python main.py --headless` to test basic functionality\n3. Look for error messages in Command Prompt\n4. Make sure all dependencies are properly installed\n\n## 🎉 Enjoy Your ChatGPT Browser!\n\nYou now have a dedicated desktop application for ChatGPT with:\n- 4 isolated workspaces for multiple accounts\n- Built-in notepad for each workspace\n- Complete session persistence\n- Professional keyboard shortcuts\n- Secure, ChatGPT-only browsing\n\nThe application saves everything automatically and restores your exact session when you restart it.","size_bytes":5940},"README.md":{"content":"# ChatGPT Browser\n\nA minimal Python-based desktop browser exclusively for ChatGPT.com with advanced workspace management and session persistence.\n\n## Features\n\n### Core Functionality\n- **Dedicated ChatGPT Browser**: Exclusively displays and interacts with chatgpt.com\n- **4 Isolated Workspaces**: Each with separate cookies, cache, and local storage\n- **Multi-Tab Support**: Multiple ChatGPT tabs per workspace\n- **Session Persistence**: Automatic saving and restoration of workspace states\n- **Built-in Notepad**: Per-workspace notepad with Markdown support\n\n### Session Management\n- **Auto-save**: Sessions saved every 4 minutes\n- **Save Triggers**: App close, workspace switch, tab close\n- **Restore on Startup**: All workspaces and tabs restored when app starts\n- **Isolated Storage**: Each workspace has completely separate data\n\n### UI & UX\n- **Dark Theme**: Modern dark interface (#141414, #282828, #3c3c3c)\n- **Workspace Switching**: Quick switching between 4 workspaces\n- **Tab Management**: Full tab management with restore functionality\n- **Keyboard Shortcuts**: Comprehensive shortcut support\n\n### Keyboard Shortcuts\n\n#### Tab Management\n- `Ctrl+T`: Open new tab\n- `Ctrl+W`: Close current tab  \n- `Ctrl+Shift+T`: Restore last closed tab\n- `Ctrl+Tab`: Next tab\n- `Ctrl+Shift+Tab`: Previous tab\n\n#### Navigation\n- `Ctrl+R`: Reload current tab\n- `Alt+Left`: Navigate back\n- `Alt+Right`: Navigate forward\n\n#### Workspace & Features\n- `Ctrl+Shift+K`: Toggle notepad\n- `Ctrl+Shift+1-4`: Switch to workspace 1-4\n\n## Installation & Usage\n\n### Development Mode (Replit)\n```bash\n# Run headless tests\npython main.py --headless\n\n# Force GUI mode (requires display)\npython main.py --gui\n```\n\n### Building Windows Executable\n\nThe application is designed to be built into a standalone Windows executable using GitHub Actions:\n\n1. **Push to GitHub**: The repository will automatically build Windows executables\n2. **Download**: Get the executable from GitHub Actions artifacts or releases\n3. **Run**: Double-click the .exe file to run the application\n\n#### Manual Build (Windows)\n```bash\n# Install dependencies\npip install PyQt6 PyQt6-WebEngine markdown pyinstaller\n\n# Build executable\npyinstaller chatgpt-browser.spec\n\n# Find executable in dist/ChatGPTBrowser/\n```\n\n## Architecture\n\n### Cross-Platform Design\n- **Windows**: Uses `%APPDATA%\\\\ChatGPT Browser` for data storage\n- **macOS**: Uses `~/Library/Application Support/ChatGPT Browser`\n- **Linux**: Uses `~/.local/share/ChatGPT Browser`\n\n### Workspace Isolation\nEach workspace maintains:\n- Separate QtWebEngine profiles\n- Independent cookies and sessions\n- Isolated local storage and cache\n- Individual notepad content\n\n### Memory Efficiency\n- Lazy loading of workspace resources\n- Proper cleanup on tab/workspace close\n- Optimized session data storage\n- Minimal memory footprint\n\n## File Structure\n\n```\n├── src/\n│   ├── config.py          # Application constants\n│   ├── paths.py           # Cross-platform path management\n│   ├── app.py            # Main application entry point\n│   ├── storage/\n│   │   └── session_manager.py  # Session persistence\n│   ├── web/\n│   │   └── workspace.py        # Web engine & workspace logic\n│   └── ui/\n│       ├── main_window.py      # Main application window\n│       └── notepad.py          # Notepad widget\n├── assets/\n│   ├── logo.png          # Application icon\n│   └── notepad.png       # Notepad toggle icon\n├── main.py               # Entry point\n├── chatgpt-browser.spec  # PyInstaller configuration\n└── .github/workflows/\n    └── build-windows.yml # Windows build automation\n```\n\n## Security & Privacy\n\n- **Isolated Profiles**: Each workspace has completely separate browser profiles\n- **Local Storage**: All data stored locally, no external data transmission\n- **Secure Defaults**: Standard web security policies applied\n- **No Tracking**: Application doesn't collect or transmit user data\n\n## Requirements\n\n### Runtime\n- Windows 10/11 (for executable)\n- Python 3.11+ (for development)\n\n### Development\n- PyQt6\n- PyQt6-WebEngine  \n- markdown\n- pyinstaller (for building)\n\n## Contributing\n\nThis project is designed for personal use but contributions are welcome for:\n- Bug fixes\n- Performance improvements\n- Cross-platform compatibility\n- Additional workspace features\n\n## License\n\nThis project is for personal use. ChatGPT and OpenAI are trademarks of their respective owners.","size_bytes":4512},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nChatGPT Browser - Entry point\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# Add src directory to Python path\nsrc_path = Path(__file__).parent / \"src\"\nsys.path.insert(0, str(src_path))\n\nfrom src.app import main\n\nif __name__ == \"__main__\":\n    sys.exit(main())","size_bytes":283},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"ChatGPT Browser - A dedicated browsing environment for ChatGPT with workspace isolation\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"markdown>=3.9\",\n]\n\n[project.optional-dependencies]\ngui = [\n    \"pyqt6>=6.9.1\",\n    \"pyqt6-webengine>=6.9.0\",\n]\n","size_bytes":320},"replit.md":{"content":"# ChatGPT Browser\n\n## Overview\n\nChatGPT Browser is a minimal Python-based desktop application that provides a dedicated browsing environment exclusively for ChatGPT.com. The application features workspace isolation, session persistence, and a built-in notepad system. It's designed to provide users with multiple isolated ChatGPT sessions while maintaining complete separation between workspaces.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Runtime Environment - Replit Setup\n- **Current Mode**: Running in headless mode for Replit environment compatibility\n- **GUI Limitations**: Full GUI mode requires complete Qt6/QtWebEngine system dependencies not available in this environment\n- **Core Functionality**: Session management, workspace isolation, and data persistence all work perfectly in headless mode\n- **Local GUI**: For full desktop GUI experience, clone locally, install GUI dependencies with `pip install .[gui]`, then run `python main.py --gui`\n\n### Frontend Architecture\n- **UI Framework**: PyQt6-based desktop application with QtWebEngine for web rendering\n- **Window Management**: Single main window with tabbed interface and workspace switching\n- **Component Structure**: Modular UI components including main window, notepad widget, and workspace management dialogs\n- **Theme**: Dark theme with consistent color palette (#141414, #282828, #3c3c3c)\n\n### Backend Architecture\n- **Session Management**: JSON-based session persistence with automatic saving every 4 minutes\n- **Data Storage**: File-system based storage with separate directories per workspace\n- **URL Filtering**: Custom interceptor restricting navigation to ChatGPT and essential OpenAI domains only\n- **Workspace Isolation**: Each workspace maintains separate QtWebEngine profiles with isolated cookies, cache, and local storage\n\n### Core Components\n- **Main Application**: Entry point with headless mode support for CI/testing\n- **Workspace Management**: 4 isolated workspaces with independent web sessions\n- **Tab Management**: Multi-tab support within each workspace with restore functionality\n- **Notepad System**: Per-workspace notepad with Markdown support and persistent storage\n- **Session Persistence**: Automatic save/restore of workspace states, tabs, and notepad content\n\n### Web Engine Configuration\n- **Profile Isolation**: Each workspace uses separate QtWebEngine profiles stored in isolated directories\n- **Security Settings**: Sandbox configuration with development/CI environment adaptations\n- **URL Restriction**: Strict filtering allowing only ChatGPT-related domains and essential resources\n\n### Data Storage Design\n- **Session Data**: JSON files storing workspace configurations, tab states, and metadata\n- **Notepad Storage**: Separate text files per workspace for notepad content\n- **Profile Data**: QtWebEngine profile directories for cookies, cache, and web storage\n- **Cross-Platform Paths**: Platform-aware directory management using Qt's standard paths with fallbacks\n\n### State Management\n- **Auto-Save Triggers**: 4-minute intervals, app close, workspace switch, and tab close events\n- **Restoration**: Complete workspace state restoration on application startup\n- **Workspace Switching**: Hot-swapping between workspaces with preserved states\n\n## External Dependencies\n\n### Core Framework\n- **PyQt6**: Main UI framework and QtWebEngine for web rendering\n- **QtWebEngineCore**: Web engine profiles, URL interception, and page management\n\n### System Integration\n- **Cross-Platform Support**: Windows (APPDATA), macOS (Library/Application Support), Linux (XDG_DATA_HOME)\n- **Headless Environment**: CI/testing support with sandbox configuration - currently active on Replit\n- **Standard Paths**: Qt's QStandardPaths for platform-appropriate data directories\n- **Replit Workflow**: Configured to run headless self-tests and verify core functionality\n\n### Web Dependencies\n- **Allowed Domains**: Restricted to chatgpt.com and essential OpenAI subdomains (auth0.openai.com, cdn.openai.com, static.openai.com, api.openai.com)\n- **CDN Resources**: Cloudflare CDN and Azure blob storage for ChatGPT assets\n- **OAuth Integration**: OpenAI authentication services through designated endpoints","size_bytes":4257},"src/__init__.py":{"content":"# ChatGPT Browser package","size_bytes":25},"src/app.py":{"content":"\"\"\"\nMain application entry point with headless mode support\n\"\"\"\n\nimport sys\nimport os\nfrom typing import Optional\n\nfrom .config import APP_NAME, APP_ORG\nfrom .paths import is_headless_environment, ensure_directories\n\n\ndef setup_environment():\n    \"\"\"Setup environment variables for proper operation\"\"\"\n    # Ensure data directories exist\n    ensure_directories()\n    \n    # Set Qt application properties (only for Linux X11)\n    if sys.platform.startswith(\"linux\") and os.environ.get(\"DISPLAY\"):\n        os.environ.setdefault(\"QT_QPA_PLATFORM\", \"xcb\")\n    \n    # Configure QtWebEngine for headless environments if needed\n    if is_headless_environment():\n        os.environ[\"QTWEBENGINE_DISABLE_SANDBOX\"] = \"1\"\n        os.environ[\"QTWEBENGINE_CHROMIUM_FLAGS\"] = (\n            \"--no-sandbox --disable-gpu --disable-software-rasterizer \"\n            \"--disable-dev-shm-usage --single-process --no-zygote\"\n        )\n\n\ndef run_headless_tests() -> bool:\n    \"\"\"Run headless tests for CI/development environments\"\"\"\n    \n    try:\n        # Test imports\n        from .storage.session_manager import SessionManager\n        from .paths import get_app_data_dir, get_sessions_file\n        \n        # Test session manager\n        session_manager = SessionManager()\n        workspaces = session_manager.load_sessions()\n        \n        # Test saving/loading\n        if not session_manager.save_sessions(workspaces):\n            return False\n        \n        # Test URL filter (skip if GUI libraries unavailable)\n        try:\n            from .web.url_filter import ChatGPTUrlFilter\n            url_filter = ChatGPTUrlFilter()\n        except ImportError:\n            pass  # Expected in headless mode\n        except Exception:\n            return False\n        \n        return True\n        \n    except Exception:\n        return False\n\n\ndef run_minimal_gui_test() -> bool:\n    \"\"\"Run minimal GUI test to verify QtWebEngine initialization\"\"\"\n    try:\n        from PyQt6.QtWidgets import QApplication\n        from PyQt6.QtWebEngineWidgets import QWebEngineView\n        from PyQt6.QtCore import QUrl, QTimer\n        \n        app = QApplication.instance()\n        if app is None:\n            app = QApplication(sys.argv)\n        \n        # Create minimal web view\n        web_view = QWebEngineView()\n        web_view.resize(400, 300)\n        \n        # Load about:blank to test QtWebEngine initialization\n        web_view.load(QUrl(\"about:blank\"))\n        \n        # Set up timer to close after 3 seconds\n        timer = QTimer()\n        timer.timeout.connect(app.quit)\n        timer.start(3000)\n        \n        web_view.deleteLater()\n        return True\n        \n    except Exception:\n        return False\n\n\ndef create_gui_application():\n    \"\"\"Create and run the GUI application\"\"\"\n    # Safety check for Replit environment\n    if \"REPLIT\" in os.environ or \"REPL_ID\" in os.environ:\n        if not os.environ.get(\"ALLOW_UNSAFE_GUI\"):\n            print(\"ERROR: GUI mode is not supported in the Replit environment.\")\n            print(\"This is due to missing system dependencies for Qt6/QtWebEngine.\")\n            print(\"To run the GUI version:\")\n            print(\"1. Clone this project locally\")\n            print(\"2. Install GUI dependencies: pip install .[gui]\")\n            print(\"3. Run: python main.py --gui\")\n            print(\"\")\n            print(\"The headless mode works perfectly and provides all core functionality.\")\n            print(\"Run: python main.py --headless\")\n            return 1\n    \n    try:\n        from PyQt6.QtWidgets import QApplication\n        from PyQt6.QtCore import Qt\n        from PyQt6.QtGui import QPalette, QColor\n        from .ui.main_window import MainWindow\n        from .config import COLORS\n        \n        # Create QApplication\n        app = QApplication(sys.argv)\n        app.setApplicationName(APP_NAME)\n        app.setOrganizationName(APP_ORG)\n        \n        # Set dark theme for the application\n        app.setStyle('Fusion')\n        palette = QPalette()\n        palette.setColor(QPalette.ColorRole.Window, QColor(COLORS['primary_bg']))\n        palette.setColor(QPalette.ColorRole.WindowText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Base, QColor(COLORS['secondary_bg']))\n        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(COLORS['accent']))\n        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Text, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Button, QColor(COLORS['secondary_bg']))\n        palette.setColor(QPalette.ColorRole.ButtonText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.BrightText, QColor('red'))\n        palette.setColor(QPalette.ColorRole.Link, QColor('#42A5F5'))\n        palette.setColor(QPalette.ColorRole.Highlight, QColor(COLORS['accent']))\n        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(COLORS['text']))\n        app.setPalette(palette)\n        \n        # Create and show main window\n        window = MainWindow()\n        window.show()\n        \n        return app.exec()\n        \n    except ImportError:\n        print(\"GUI libraries not available. Install PyQt6 and run on a system with a display.\")\n        return 1\n    except Exception as e:\n        print(f\"Error starting application: {e}\")\n        return 1\n\n\ndef main() -> int:\n    \"\"\"Main entry point\"\"\"\n    # Setup environment\n    setup_environment()\n    \n    # Check if we should run minimal GUI test\n    if \"--gui-test\" in sys.argv:\n        return 0 if run_minimal_gui_test() else 1\n    \n    # Check if we should run in headless mode\n    if is_headless_environment() or \"--headless\" in sys.argv:\n        if run_headless_tests():\n            print(\"\\nTo run the GUI version:\")\n            print(\"1. Install PyQt6 and QtWebEngine\")\n            print(\"2. Run on a system with a graphical display\")\n            print(\"3. Or use: python main.py --gui (forces GUI mode)\")\n            return 0\n        else:\n            return 1\n    \n    # Force GUI mode if requested\n    if \"--gui\" in sys.argv:\n        print(\"Forcing GUI mode...\")\n    \n    # Run GUI application\n    print(f\"Starting {APP_NAME}...\")\n    return create_gui_application()\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())","size_bytes":6353},"src/config.py":{"content":"\"\"\"\nConfiguration constants for ChatGPT Browser\n\"\"\"\n\n# Application constants\nAPP_NAME = \"ChatGPT Browser\"\nAPP_ORG = \"ChatGPT Browser\"\nCHATGPT_URL = \"https://chatgpt.com\"\nNUM_WORKSPACES = 4\nAUTOSAVE_INTERVAL_MS = 10 * 60 * 1000  # 10 minutes in milliseconds (reduced SSD wear)\nNOTEPAD_SAVE_DEBOUNCE_MS = 2 * 1000  # 2 second debounce for notepad saves\n\n# UI Constants\nCOLORS = {\n    'primary_bg': '#141414',\n    'secondary_bg': '#282828', \n    'accent': '#3c3c3c',\n    'text': '#ffffff',\n    'text_dim': '#cccccc'\n}\n\n# Default workspace names\nDEFAULT_WORKSPACE_NAMES = [f\"Workspace {i+1}\" for i in range(NUM_WORKSPACES)]\n\n# File names\nSESSION_FILE = \"sessions.json\"\nNOTEPAD_DIR = \"notepads\"\nASSETS_DIR = \"assets\"","size_bytes":711},"src/paths.py":{"content":"\"\"\"\nCross-platform path management for ChatGPT Browser\n\"\"\"\n\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\n\ndef get_app_data_dir() -> Path:\n    \"\"\"Get the application data directory for the current platform\"\"\"\n    try:\n        from PyQt6.QtCore import QStandardPaths\n        # Use Qt's standard paths for cross-platform compatibility\n        app_data = QStandardPaths.writableLocation(\n            QStandardPaths.StandardLocation.AppDataLocation\n        )\n        if app_data:\n            return Path(app_data)\n    except ImportError:\n        pass\n    \n    # Fallback to manual platform detection\n    if sys.platform == \"win32\":\n        # Windows: %APPDATA%\\ChatGPT Browser\n        app_data = os.environ.get(\"APPDATA\")\n        if app_data:\n            return Path(app_data) / \"ChatGPT Browser\"\n    elif sys.platform == \"darwin\":\n        # macOS: ~/Library/Application Support/ChatGPT Browser\n        home = Path.home()\n        return home / \"Library\" / \"Application Support\" / \"ChatGPT Browser\"\n    else:\n        # Linux: ~/.local/share/ChatGPT Browser\n        xdg_data = os.environ.get(\"XDG_DATA_HOME\")\n        if xdg_data:\n            return Path(xdg_data) / \"ChatGPT Browser\"\n        return Path.home() / \".local\" / \"share\" / \"ChatGPT Browser\"\n    \n    # Ultimate fallback\n    return Path.home() / \".chatgpt-browser\"\n\ndef get_workspace_data_dir(workspace_id: int) -> Path:\n    \"\"\"Get the data directory for a specific workspace\"\"\"\n    base_dir = get_app_data_dir()\n    return base_dir / f\"workspace_{workspace_id}\"\n\ndef get_workspace_profile_dir(workspace_id: int) -> Path:\n    \"\"\"Get the QtWebEngine profile directory for a specific workspace\"\"\"\n    return get_workspace_data_dir(workspace_id) / \"profile\"\n\ndef get_workspace_notepad_file(workspace_id: int) -> Path:\n    \"\"\"Get the notepad file path for a specific workspace\"\"\"\n    return get_workspace_data_dir(workspace_id) / \"notepad.md\"\n\ndef get_sessions_file() -> Path:\n    \"\"\"Get the sessions file path\"\"\"\n    return get_app_data_dir() / \"sessions.json\"\n\ndef ensure_directories():\n    \"\"\"Ensure all necessary directories exist\"\"\"\n    # Create main app data directory\n    get_app_data_dir().mkdir(parents=True, exist_ok=True)\n    \n    # Create workspace directories\n    for i in range(4):  # 4 workspaces\n        get_workspace_data_dir(i).mkdir(parents=True, exist_ok=True)\n        get_workspace_profile_dir(i).mkdir(parents=True, exist_ok=True)\n\ndef get_assets_dir() -> Path:\n    \"\"\"Get the assets directory (relative to script location)\"\"\"\n    # In development, assets are relative to the script\n    # In packaged app, they'll be in the bundle\n    if getattr(sys, 'frozen', False):\n        # Running in PyInstaller bundle\n        bundle_dir = Path(getattr(sys, '_MEIPASS', '.'))\n        return bundle_dir / \"assets\"\n    else:\n        # Running in development\n        script_dir = Path(__file__).parent.parent\n        return script_dir / \"assets\"\n\ndef is_headless_environment() -> bool:\n    \"\"\"Check if we're running in a headless environment\"\"\"\n    # Check for common headless indicators\n    if os.environ.get(\"HEADLESS\") == \"1\":\n        return True\n    \n    # Check if DISPLAY is set on Linux\n    if sys.platform.startswith(\"linux\") and not os.environ.get(\"DISPLAY\"):\n        return True\n    \n    # Check for CI environment variables\n    ci_indicators = [\"CI\", \"GITHUB_ACTIONS\", \"TRAVIS\", \"JENKINS\", \"REPLIT\"]\n    if any(os.environ.get(var) for var in ci_indicators):\n        return True\n    \n    return False","size_bytes":3497},"src/storage/__init__.py":{"content":"# Storage module","size_bytes":16},"src/storage/session_manager.py":{"content":"\"\"\"\nSession management for workspace persistence\n\"\"\"\n\nimport json\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\nimport hashlib\n\nfrom ..config import CHATGPT_URL, DEFAULT_WORKSPACE_NAMES\nfrom ..paths import get_sessions_file, get_workspace_notepad_file, ensure_directories\n\n\n@dataclass\nclass TabData:\n    \"\"\"Data structure for tab information\"\"\"\n    url: str\n    title: str = \"ChatGPT\"\n\n\n@dataclass \nclass WorkspaceData:\n    \"\"\"Data structure for workspace information\"\"\"\n    name: str\n    tabs: List[TabData]\n    active_tab: int = 0\n    notepad_content: str = \"\"\n    notepad_visible: bool = False\n\n\nclass SessionManager:\n    \"\"\"Handles session persistence and auto-save functionality\"\"\"\n    \n    def __init__(self):\n        self.session_file = get_sessions_file()\n        self._last_session_hash = None\n        self._last_notepad_hashes = {}\n        ensure_directories()\n    \n    def _compute_content_hash(self, content: str) -> str:\n        \"\"\"Compute hash of content for change detection\"\"\"\n        return hashlib.md5(content.encode('utf-8')).hexdigest()\n    \n    def save_sessions(self, workspaces: Dict[int, WorkspaceData]) -> bool:\n        \"\"\"Save workspace sessions to file (only if changed)\"\"\"\n        try:\n            session_data = {}\n            files_written = 0\n            \n            for workspace_id, workspace_data in workspaces.items():\n                # Check if notepad content has changed\n                notepad_content = workspace_data.notepad_content\n                notepad_hash = self._compute_content_hash(notepad_content)\n                \n                if notepad_hash != self._last_notepad_hashes.get(workspace_id):\n                    # Only write notepad file if content changed\n                    notepad_file = get_workspace_notepad_file(workspace_id)\n                    notepad_file.write_text(notepad_content, encoding='utf-8')\n                    self._last_notepad_hashes[workspace_id] = notepad_hash\n                    files_written += 1\n                \n                # Prepare session data (without notepad content and without timestamp for hash)\n                session_data[str(workspace_id)] = {\n                    'name': workspace_data.name,\n                    'tabs': [asdict(tab) for tab in workspace_data.tabs],\n                    'active_tab': workspace_data.active_tab,\n                    'notepad_visible': workspace_data.notepad_visible\n                }\n            \n            # Check if session data has changed (compute hash WITHOUT timestamp)\n            session_json = json.dumps(session_data, sort_keys=True)\n            session_hash = self._compute_content_hash(session_json)\n            \n            if session_hash != self._last_session_hash:\n                # Add timestamp only when we decide to write\n                current_time = time.time()\n                for workspace_data in session_data.values():\n                    workspace_data['last_saved'] = current_time\n                \n                # Only write session file if data changed\n                with open(self.session_file, 'w', encoding='utf-8') as f:\n                    json.dump(session_data, f, indent=2)\n                self._last_session_hash = session_hash\n                files_written += 1\n            \n            return True\n            \n        except Exception:\n            return False\n    \n    def load_sessions(self) -> Dict[int, WorkspaceData]:\n        \"\"\"Load workspace sessions from file\"\"\"\n        if not self.session_file.exists():\n            return self._create_default_workspaces()\n        \n        try:\n            with open(self.session_file, 'r', encoding='utf-8') as f:\n                session_data = json.load(f)\n            \n            workspaces = {}\n            for workspace_id_str, data in session_data.items():\n                workspace_id = int(workspace_id_str)\n                \n                # Load tabs\n                tabs = [TabData(**tab_data) for tab_data in data.get('tabs', [])]\n                if not tabs:  # Ensure at least one tab\n                    tabs = [TabData(url=CHATGPT_URL)]\n                \n                # Load notepad content from separate file\n                notepad_file = get_workspace_notepad_file(workspace_id)\n                notepad_content = \"\"\n                if notepad_file.exists():\n                    try:\n                        notepad_content = notepad_file.read_text(encoding='utf-8')\n                    except Exception:\n                        pass  # Use empty notepad content\n                \n                workspaces[workspace_id] = WorkspaceData(\n                    name=data.get('name', DEFAULT_WORKSPACE_NAMES[workspace_id]),\n                    tabs=tabs,\n                    active_tab=max(0, min(data.get('active_tab', 0), len(tabs) - 1)),\n                    notepad_content=notepad_content,\n                    notepad_visible=data.get('notepad_visible', False)\n                )\n            \n            # Ensure we have all 4 workspaces\n            for i in range(4):\n                if i not in workspaces:\n                    workspaces[i] = WorkspaceData(\n                        name=DEFAULT_WORKSPACE_NAMES[i],\n                        tabs=[TabData(url=CHATGPT_URL)],\n                        active_tab=0,\n                        notepad_content=\"\",\n                        notepad_visible=False\n                    )\n            \n            return workspaces\n            \n        except Exception:\n            return self._create_default_workspaces()\n    \n    def _create_default_workspaces(self) -> Dict[int, WorkspaceData]:\n        \"\"\"Create default workspace configuration\"\"\"\n        return {\n            i: WorkspaceData(\n                name=DEFAULT_WORKSPACE_NAMES[i],\n                tabs=[TabData(url=CHATGPT_URL)],\n                active_tab=0,\n                notepad_content=\"\",\n                notepad_visible=False\n            )\n            for i in range(4)\n        }\n    \n    def backup_sessions(self) -> bool:\n        \"\"\"Create a backup of current sessions\"\"\"\n        if not self.session_file.exists():\n            return False\n            \n        try:\n            import shutil\n            backup_file = self.session_file.with_suffix('.backup.json')\n            shutil.copy2(self.session_file, backup_file)\n            return True\n        except Exception:\n            return False","size_bytes":6427},"src/ui/__init__.py":{"content":"# UI module","size_bytes":11},"src/ui/main_window.py":{"content":"\"\"\"\nMain application window with workspace management\n\"\"\"\n\nfrom typing import Dict, Optional\nfrom PyQt6.QtWidgets import (\n    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,\n    QFrame, QPushButton, QStackedWidget, QMenu,\n    QDialog, QLineEdit, QLabel, QDialogButtonBox,\n    QSplitter\n)\nfrom PyQt6.QtCore import Qt, QTimer, pyqtSignal\nfrom PyQt6.QtGui import QIcon, QKeySequence, QShortcut, QFont\n\nfrom ..config import COLORS, NUM_WORKSPACES, AUTOSAVE_INTERVAL_MS\nfrom ..paths import get_assets_dir\nfrom ..storage.session_manager import SessionManager, WorkspaceData\nfrom ..web.workspace import WorkspaceWidget\nfrom .notepad import NotepadWidget\nfrom .notifications import NotificationWidget, StatusIndicator\nfrom .memory_manager import MemoryManager\nfrom .animated_widgets import AnimatedStackedWidget, SplitterAnimator\n\n\nclass WorkspaceRenameDialog(QDialog):\n    \"\"\"Dialog for renaming workspaces\"\"\"\n    \n    def __init__(self, current_name: str, parent=None):\n        super().__init__(parent)\n        self.setWindowTitle(\"Rename Workspace\")\n        self.setModal(True)\n        self.setup_ui(current_name)\n        self.setup_style()\n    \n    def setup_ui(self, current_name: str):\n        \"\"\"Setup dialog UI\"\"\"\n        layout = QVBoxLayout(self)\n        \n        self.name_edit = QLineEdit(current_name)\n        self.name_edit.selectAll()\n        layout.addWidget(QLabel(\"Workspace Name:\"))\n        layout.addWidget(self.name_edit)\n        \n        # Buttons\n        buttons = QDialogButtonBox(\n            QDialogButtonBox.StandardButton.Ok | \n            QDialogButtonBox.StandardButton.Cancel\n        )\n        buttons.accepted.connect(self.accept)\n        buttons.rejected.connect(self.reject)\n        layout.addWidget(buttons)\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QDialog {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n            }}\n            QLineEdit {{\n                background-color: {COLORS['primary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 3px;\n                padding: 5px;\n                color: {COLORS['text']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['accent']};\n                border: none;\n                border-radius: 3px;\n                padding: 5px 10px;\n                color: {COLORS['text']};\n            }}\n            QPushButton:hover {{\n                background-color: #4c4c4c;\n            }}\n            QLabel {{\n                color: {COLORS['text']};\n            }}\n        \"\"\")\n    \n    def get_name(self) -> str:\n        \"\"\"Get the entered workspace name\"\"\"\n        return self.name_edit.text().strip()\n\n\nclass MainWindow(QMainWindow):\n    \"\"\"Main application window\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self.session_manager = SessionManager()\n        self.workspaces: Dict[int, WorkspaceWidget] = {}\n        self.notepads: Dict[int, NotepadWidget] = {}\n        self.current_workspace = 0\n        \n        # Change tracking flags\n        self.session_dirty = False\n        self.notepad_dirty = False\n        \n        # Create notification system\n        self.notification_widget = NotificationWidget(self)\n        \n        # Create status indicator for loading progress\n        self.status_indicator = StatusIndicator(self)\n        \n        # Memory manager for intelligent workspace compression\n        self.memory_manager = MemoryManager(self)\n        self.memory_manager.workspace_needs_loading.connect(self._handle_workspace_loading)\n        self.memory_manager.compress_workspace_signal.connect(self._compress_workspace)\n        \n        # Splitter animator for smooth notepad transitions\n        self.splitter_animator = SplitterAnimator(self)\n        \n        # Auto-save timer\n        self.autosave_timer = QTimer()\n        self.autosave_timer.timeout.connect(self.save_sessions)\n        self.autosave_timer.start(AUTOSAVE_INTERVAL_MS)\n        \n        self.setup_ui()\n        self.setup_shortcuts()\n        self.load_sessions()\n        self.setup_style()\n        \n        # Set initial window title with current workspace\n        self.update_window_title()\n    \n    def setup_ui(self):\n        \"\"\"Setup the main UI\"\"\"\n        self.setWindowTitle(\"ChatGPT Browser\")\n        self.setGeometry(100, 100, 1200, 800)\n        \n        # Set window icon\n        assets_dir = get_assets_dir()\n        logo_path = assets_dir / \"logo.png\"\n        if logo_path.exists():\n            self.setWindowIcon(QIcon(str(logo_path)))\n        \n        # Central widget\n        central_widget = QWidget()\n        self.setCentralWidget(central_widget)\n        layout = QVBoxLayout(central_widget)\n        layout.setContentsMargins(0, 0, 0, 0)\n        \n        # Add status indicator at top (initially hidden)\n        layout.addWidget(self.status_indicator)\n        self.status_indicator.hide()\n        \n        # Create container for main content with workspace pill overlay\n        content_container = QWidget()\n        content_layout = QVBoxLayout(content_container)\n        content_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # Main content area with workspaces (no header) - using animated version\n        self.workspace_stack = AnimatedStackedWidget()\n        content_layout.addWidget(self.workspace_stack)\n        \n        # Add workspace pill indicator (floating in top-right corner)\n        self.workspace_pill = self.create_workspace_pill()\n        \n        layout.addWidget(content_container)\n        \n        # Store workspace names for minimal display\n        self.workspace_names = [f\"Workspace {i+1}\" for i in range(NUM_WORKSPACES)]\n        \n    def create_workspace_pill(self) -> QWidget:\n        \"\"\"Create the floating workspace indicator pill\"\"\"\n        pill = QWidget(self)\n        pill.setObjectName(\"workspace-pill\")\n        pill.setFixedHeight(32)\n        pill.setMinimumWidth(120)\n        pill.setMaximumWidth(200)\n        \n        # Create layout\n        pill_layout = QHBoxLayout(pill)\n        pill_layout.setContentsMargins(12, 6, 12, 6)\n        pill_layout.setSpacing(8)\n        \n        # Workspace name label\n        self.workspace_label = QLabel(self.get_current_workspace_name())\n        self.workspace_label.setFont(QFont(\"Arial\", 10, QFont.Weight.Bold))\n        pill_layout.addWidget(self.workspace_label)\n        \n        # Styling for the pill\n        pill.setStyleSheet(f\"\"\"\n            QWidget#workspace-pill {{\n                background-color: {COLORS['secondary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 16px;\n                color: {COLORS['text']};\n            }}\n            QLabel {{\n                color: {COLORS['text']};\n                border: none;\n            }}\n        \"\"\")\n        \n        # Position the pill in top-right corner\n        pill.move(self.width() - pill.width() - 20, 20)\n        pill.show()\n        \n        return pill\n    \n    def get_current_workspace_name(self) -> str:\n        \"\"\"Get the name of the current workspace\"\"\"\n        return self.workspace_names[self.current_workspace]\n    \n    def update_window_title(self):\n        \"\"\"Update window title with current workspace name\"\"\"\n        workspace_name = self.get_current_workspace_name()\n        self.setWindowTitle(f\"ChatGPT Browser - {workspace_name}\")\n        \n        # Update workspace pill\n        if hasattr(self, 'workspace_label'):\n            self.workspace_label.setText(workspace_name)\n    \n    def resizeEvent(self, event):\n        \"\"\"Handle window resize to reposition workspace pill\"\"\"\n        super().resizeEvent(event)\n        if hasattr(self, 'workspace_pill'):\n            # Reposition pill to top-right corner\n            self.workspace_pill.move(self.width() - self.workspace_pill.width() - 20, 20)\n    \n    def setup_shortcuts(self):\n        \"\"\"Setup keyboard shortcuts\"\"\"\n        # Tab management\n        QShortcut(QKeySequence(\"Ctrl+T\"), self, self.new_tab)\n        QShortcut(QKeySequence(\"Ctrl+W\"), self, self.close_current_tab)\n        QShortcut(QKeySequence(\"Ctrl+Shift+T\"), self, self.restore_last_closed_tab)\n        QShortcut(QKeySequence(\"Ctrl+Tab\"), self, self.next_tab)\n        QShortcut(QKeySequence(\"Ctrl+Shift+Tab\"), self, self.previous_tab)\n        \n        # Navigation\n        QShortcut(QKeySequence(\"Ctrl+R\"), self, self.reload_current_tab)\n        QShortcut(QKeySequence(\"Alt+Left\"), self, self.navigate_back)\n        QShortcut(QKeySequence(\"Alt+Right\"), self, self.navigate_forward)\n        \n        # Workspace and features\n        QShortcut(QKeySequence(\"Ctrl+Shift+K\"), self, self.toggle_current_notepad)\n        QShortcut(QKeySequence(\"Ctrl+Shift+1\"), self, lambda: self.switch_workspace(0))\n        QShortcut(QKeySequence(\"Ctrl+Shift+2\"), self, lambda: self.switch_workspace(1))\n        QShortcut(QKeySequence(\"Ctrl+Shift+3\"), self, lambda: self.switch_workspace(2))\n        QShortcut(QKeySequence(\"Ctrl+Shift+4\"), self, lambda: self.switch_workspace(3))\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QMainWindow {{\n                background-color: {COLORS['primary_bg']};\n                color: {COLORS['text']};\n            }}\n            QFrame {{\n                background-color: {COLORS['secondary_bg']};\n                border-bottom: 1px solid {COLORS['accent']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 5px;\n                padding: 8px 12px;\n                font-weight: bold;\n            }}\n            QPushButton:checked {{\n                background-color: {COLORS['accent']};\n                border-color: #5c5c5c;\n            }}\n            QPushButton:hover {{\n                background-color: {COLORS['accent']};\n            }}\n            QStackedWidget {{\n                background-color: {COLORS['primary_bg']};\n            }}\n        \"\"\")\n    \n    def load_sessions(self):\n        \"\"\"Load workspace sessions\"\"\"\n        # Show status indicator and start loading progress\n        self.status_indicator.show()\n        self.status_indicator.set_status(\"Initializing workspaces...\")\n        \n        workspace_data = self.session_manager.load_sessions()\n        total_workspaces = len(workspace_data)\n        \n        for i, (workspace_id, data) in enumerate(workspace_data.items(), 1):\n            # Update progress\n            self.status_indicator.set_status(f\"Loading workspace {i}/{total_workspaces}...\")\n            # Create workspace widget\n            workspace_widget = WorkspaceWidget(workspace_id, data, self.toggle_current_notepad, self)\n            workspace_widget.session_changed.connect(self._mark_session_dirty)\n            workspace_widget.notification_requested.connect(\n                lambda msg: self.notification_widget.show_notification(msg, 4000)\n            )\n            \n            self.workspaces[workspace_id] = workspace_widget\n            \n            # Create notepad widget\n            notepad_widget = NotepadWidget(self)\n            notepad_widget.set_content(data.notepad_content)\n            notepad_widget.content_changed.connect(self._mark_notepad_dirty)\n            notepad_widget.close_requested.connect(lambda: self.toggle_current_notepad(False))\n            self.notepads[workspace_id] = notepad_widget\n            \n            # Create combined widget with splitter\n            from PyQt6.QtWidgets import QSplitter\n            combined_widget = QWidget()\n            layout = QVBoxLayout(combined_widget)\n            layout.setContentsMargins(0, 0, 0, 0)\n            \n            splitter = QSplitter(Qt.Orientation.Vertical)\n            splitter.setObjectName(\"main-splitter\")\n            splitter.addWidget(workspace_widget)\n            splitter.addWidget(notepad_widget)\n            splitter.setSizes([800, 0])  # Hide notepad initially\n            \n            if data.notepad_visible:\n                splitter.setSizes([600, 200])\n                notepad_widget.show()\n            else:\n                notepad_widget.hide()\n            \n            layout.addWidget(splitter)\n            self.workspace_stack.addWidget(combined_widget)\n            \n            # Update workspace name\n            if workspace_id < len(self.workspace_names):\n                self.workspace_names[workspace_id] = data.name\n        \n        # Hide status indicator and show completion notification\n        self.status_indicator.hide()\n        self.notification_widget.show_notification(\"✓ All workspaces loaded successfully\", 2000)\n    \n    def _mark_session_dirty(self):\n        \"\"\"Mark session data as dirty (needs saving)\"\"\"\n        self.session_dirty = True\n    \n    def _mark_notepad_dirty(self):\n        \"\"\"Mark notepad data as dirty (needs saving)\"\"\"\n        self.notepad_dirty = True\n    \n    \n    def save_sessions(self):\n        \"\"\"Save current workspace sessions (optimized with change detection)\"\"\"\n        # Check if we have any changes to save\n        if not (self.session_dirty or self.notepad_dirty):\n            # Timer-based save with no changes - skip to reduce I/O\n            return\n        \n        workspace_data = {}\n        for workspace_id in range(NUM_WORKSPACES):\n            if workspace_id in self.workspaces and workspace_id in self.notepads:\n                session_data = self.workspaces[workspace_id].get_session_data()\n                # Update notepad content\n                session_data.notepad_content = self.notepads[workspace_id].get_content()\n                session_data.notepad_visible = self.notepads[workspace_id].isVisible()\n                workspace_data[workspace_id] = session_data\n        \n        # Save to session manager\n        if self.session_manager.save_sessions(workspace_data):\n            # Clear change flags only after successful save\n            self.session_dirty = False\n            self.notepad_dirty = False\n            \n            # Clear notepad change flags\n            for notepad in self.notepads.values():\n                notepad.clear_changes_flag()\n    \n    def switch_workspace(self, workspace_id: int):\n        \"\"\"Switch to specified workspace\"\"\"\n        if workspace_id == self.current_workspace or workspace_id >= NUM_WORKSPACES:\n            return\n        \n        # Save current workspace session\n        self.save_sessions()\n        \n        # Track workspace usage for memory management\n        self.memory_manager.mark_workspace_used(workspace_id)\n        \n        # Check if workspace needs to be restored from compression\n        if self.memory_manager.is_workspace_compressed(workspace_id):\n            workspace_widget = self.workspaces.get(workspace_id)\n            if workspace_widget:\n                self.memory_manager.restore_workspace(workspace_id, workspace_widget)\n        \n        # Switch workspace\n        self.current_workspace = workspace_id\n        self.workspace_stack.setCurrentIndex(workspace_id)\n        \n        # Update window title to show current workspace\n        self.update_window_title()\n    \n    def show_workspace_context_menu(self, workspace_id: int, pos):\n        \"\"\"Show context menu for workspace renaming - not used in minimal UI\"\"\"\n        # Context menu functionality removed in minimal design\n        pass\n    \n    def rename_workspace(self, workspace_id: int):\n        \"\"\"Rename a workspace\"\"\"\n        current_name = self.workspace_names[workspace_id]\n        dialog = WorkspaceRenameDialog(current_name, self)\n        \n        if dialog.exec() == QDialog.DialogCode.Accepted:\n            new_name = dialog.get_name()\n            if new_name:\n                self.workspace_names[workspace_id] = new_name\n                if workspace_id in self.workspaces:\n                    self.workspaces[workspace_id].workspace_data.name = new_name\n                # Update window title if this is the current workspace\n                if workspace_id == self.current_workspace:\n                    self.setWindowTitle(f\"ChatGPT Browser - {new_name}\")\n                self._mark_session_dirty()\n                self.save_sessions()\n    \n    def get_current_workspace(self) -> Optional[WorkspaceWidget]:\n        \"\"\"Get the currently active workspace widget\"\"\"\n        return self.workspaces.get(self.current_workspace)\n    \n    def get_current_notepad(self) -> Optional[NotepadWidget]:\n        \"\"\"Get the currently active notepad widget\"\"\"\n        return self.notepads.get(self.current_workspace)\n    \n    def _handle_workspace_loading(self, workspace_id: int):\n        \"\"\"Handle workspace loading when switching to a compressed workspace\"\"\"\n        # This is called when switching to a compressed workspace\n        # The restore_workspace method in memory_manager handles the actual restoration\n        pass\n    \n    def _compress_workspace(self, workspace_id: int):\n        \"\"\"Compress an unused workspace to save memory\"\"\"\n        if workspace_id == self.current_workspace:\n            # Don't compress the currently active workspace\n            return\n            \n        workspace_widget = self.workspaces.get(workspace_id)\n        if workspace_widget:\n            self.memory_manager.compress_workspace(workspace_id, workspace_widget)\n    \n    # Tab management methods\n    def new_tab(self):\n        \"\"\"Create new tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.new_tab()\n    \n    def close_current_tab(self):\n        \"\"\"Close current tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            current_index = workspace.tab_widget.currentIndex()\n            workspace.close_tab(current_index)\n    \n    def restore_last_closed_tab(self):\n        \"\"\"Restore last closed tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.restore_last_closed_tab()\n    \n    def next_tab(self):\n        \"\"\"Switch to next tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            count = workspace.tab_widget.count()\n            current = workspace.tab_widget.currentIndex()\n            next_index = (current + 1) % count\n            workspace.tab_widget.setCurrentIndex(next_index)\n    \n    def previous_tab(self):\n        \"\"\"Switch to previous tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            count = workspace.tab_widget.count()\n            current = workspace.tab_widget.currentIndex()\n            prev_index = (current - 1) % count\n            workspace.tab_widget.setCurrentIndex(prev_index)\n    \n    # Navigation methods\n    def reload_current_tab(self):\n        \"\"\"Reload current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.reload_current_tab()\n    \n    def navigate_back(self):\n        \"\"\"Navigate back in current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.navigate_back()\n    \n    def navigate_forward(self):\n        \"\"\"Navigate forward in current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.navigate_forward()\n    \n    def toggle_current_notepad(self, show: Optional[bool] = None):\n        \"\"\"Toggle notepad for current workspace with smooth animation\"\"\"\n        notepad = self.get_current_notepad()\n        if notepad:\n            # Get the splitter from the current workspace\n            current_widget = self.workspace_stack.currentWidget()\n            if current_widget:\n                splitter = current_widget.findChild(QSplitter, \"main-splitter\")\n                if splitter:\n                    if show is None:\n                        show = not notepad.isVisible()\n                    \n                    if show:\n                        notepad.show()\n                        # Animate to show notepad\n                        self.splitter_animator.animate_to_sizes(splitter, [600, 200])\n                    else:\n                        # Animate to hide notepad, then hide widget after animation\n                        def hide_after_animation():\n                            notepad.hide()\n                        self.splitter_animator.animation_finished.connect(hide_after_animation)\n                        self.splitter_animator.animate_to_sizes(splitter, [800, 0])\n                    \n                    self._mark_session_dirty()\n                    self.save_sessions()\n    \n    def closeEvent(self, a0):\n        \"\"\"Handle application close event\"\"\"\n        # Force immediate save of any pending notepad changes\n        self._force_save_pending_changes()\n        \n        # Save sessions before closing\n        self.save_sessions()\n        \n        # Clean up resources\n        for workspace in self.workspaces.values():\n            workspace.cleanup()\n        \n        if a0:\n            a0.accept()\n    \n    def _force_save_pending_changes(self):\n        \"\"\"Force immediate save of any pending notepad changes that haven't triggered dirty flags yet\"\"\"\n        # Check each notepad for unsaved changes and stop any pending debounce timers\n        for notepad in self.notepads.values():\n            # Stop any pending debounce timers to prevent them from firing after we've saved\n            if hasattr(notepad, '_save_timer') and notepad._save_timer.isActive():\n                notepad._save_timer.stop()\n            \n            # If notepad has changes that haven't been marked dirty yet, mark them now\n            if notepad.has_changes():\n                self.notepad_dirty = True\n                # Force the content_changed signal to fire immediately\n                notepad._emit_content_changed()","size_bytes":21962},"src/ui/notepad.py":{"content":"\"\"\"\nNotepad widget with Markdown support\n\"\"\"\n\nfrom PyQt6.QtWidgets import (\n    QWidget, QVBoxLayout, QHBoxLayout, QLabel, \n    QPushButton, QTextEdit, QFrame\n)\nfrom PyQt6.QtCore import Qt, pyqtSignal, QTimer\nfrom PyQt6.QtGui import QFont\n\nfrom ..config import COLORS, NOTEPAD_SAVE_DEBOUNCE_MS\n\n\nclass NotepadWidget(QWidget):\n    \"\"\"Notepad widget with Markdown support\"\"\"\n    \n    content_changed = pyqtSignal()\n    close_requested = pyqtSignal()\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setup_ui()\n        self.setup_style()\n        self._content_changed = False\n        \n        # Debounce timer for efficient saving\n        self._save_timer = QTimer()\n        self._save_timer.setSingleShot(True)\n        self._save_timer.timeout.connect(self._emit_content_changed)\n        self._debounce_delay = NOTEPAD_SAVE_DEBOUNCE_MS\n    \n    def setup_ui(self):\n        \"\"\"Setup the notepad UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(10, 10, 10, 10)\n        \n        # Header\n        header = QHBoxLayout()\n        self.title_label = QLabel(\"Notepad\")\n        self.title_label.setFont(QFont(\"Arial\", 12, QFont.Weight.Bold))\n        header.addWidget(self.title_label)\n        header.addStretch()\n        \n        # Close button\n        self.close_btn = QPushButton(\"×\")\n        self.close_btn.setFixedSize(20, 20)\n        self.close_btn.clicked.connect(self.close_requested.emit)\n        header.addWidget(self.close_btn)\n        \n        layout.addLayout(header)\n        \n        # Text editor\n        self.text_edit = QTextEdit()\n        self.text_edit.setFont(QFont(\"Consolas\", 10))\n        self.text_edit.textChanged.connect(self._on_text_changed)\n        self.text_edit.setPlaceholderText(\"Write your notes here... Markdown is supported!\")\n        layout.addWidget(self.text_edit)\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 5px;\n            }}\n            QTextEdit {{\n                background-color: {COLORS['primary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 3px;\n                padding: 8px;\n                font-family: 'Consolas', monospace;\n                color: {COLORS['text']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['accent']};\n                border: none;\n                border-radius: 10px;\n                font-weight: bold;\n                color: {COLORS['text']};\n            }}\n            QPushButton:hover {{\n                background-color: #4c4c4c;\n            }}\n            QLabel {{\n                border: none;\n                color: {COLORS['text']};\n            }}\n        \"\"\")\n    \n    def _on_text_changed(self):\n        \"\"\"Mark content as changed when text is modified\"\"\"\n        self._content_changed = True\n        # Debounce the save signal to avoid excessive I/O\n        self._save_timer.stop()\n        self._save_timer.start(self._debounce_delay)\n    \n    def _emit_content_changed(self):\n        \"\"\"Emit content changed signal after debounce delay\"\"\"\n        if self._content_changed:\n            self.content_changed.emit()\n    \n    def set_content(self, content: str):\n        \"\"\"Set notepad content\"\"\"\n        self.text_edit.setPlainText(content)\n        self._content_changed = False\n    \n    def get_content(self) -> str:\n        \"\"\"Get notepad content\"\"\"\n        return self.text_edit.toPlainText()\n    \n    def has_changes(self) -> bool:\n        \"\"\"Check if content has been modified\"\"\"\n        return self._content_changed\n    \n    def clear_changes_flag(self):\n        \"\"\"Clear the changes flag (called after saving)\"\"\"\n        self._content_changed = False","size_bytes":3948},"src/web/__init__.py":{"content":"# Web module","size_bytes":12},"src/web/url_filter.py":{"content":"\"\"\"\nURL filtering to restrict navigation to ChatGPT domains only\n\"\"\"\n\nfrom PyQt6.QtCore import QObject, QUrl\nfrom PyQt6.QtWebEngineCore import QWebEngineUrlRequestInterceptor, QWebEngineUrlRequestInfo\n\n\nclass ChatGPTUrlFilter(QWebEngineUrlRequestInterceptor):\n    \"\"\"URL filter to restrict navigation to ChatGPT domains only\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # Allowed domains for ChatGPT functionality (minimal and specific)\n        self.allowed_domains = {\n            'chatgpt.com',\n            # Complete OAuth/Auth domains for login flows\n            'auth0.openai.com',\n            'auth.openai.com', \n            'login.openai.com',\n            'openai.auth0.com',\n            # Essential OpenAI API and CDN domains\n            'cdn.openai.com', \n            'static.openai.com',\n            'api.openai.com',\n            'files.oaiusercontent.com',\n            # CRITICAL: Main ChatGPT CDN for CSS/JS resources\n            'cdn.oaistatic.com',\n            'oaistatic.com',\n            # Specific CDN subdomains that ChatGPT actually uses\n            'cdnjs.cloudflare.com',\n            'chat.openai.com.cdn.cloudflare.net',\n            # Required for OAuth and essential functionality\n            'openaiapi-site.azureedge.net',\n            'openaicomproductionae4b.blob.core.windows.net',\n            # Additional voice features\n            'chatgpt.livekit.cloud'\n        }\n        \n        # Allowed URL patterns for specific resources\n        self.allowed_patterns = [\n            'data:',  # Data URLs for images, etc.\n            'blob:',  # Blob URLs for file handling\n            'about:blank',  # Blank pages\n        ]\n    \n    def interceptRequest(self, info: QWebEngineUrlRequestInfo):\n        \"\"\"Intercept and filter URL requests\"\"\"\n        url = info.requestUrl()\n        url_string = url.toString()\n        \n        # Allow specific URL patterns\n        for pattern in self.allowed_patterns:\n            if url_string.startswith(pattern):\n                return\n        \n        # Check domain\n        host = url.host().lower()\n        \n        # Allow main domain and subdomains\n        allowed = False\n        for domain in self.allowed_domains:\n            if host == domain or host.endswith('.' + domain):\n                allowed = True\n                break\n        \n        # Block if not allowed\n        if not allowed:\n            info.block(True)\n            return\n        \n        # Allow the request explicitly\n        info.block(False)","size_bytes":2531},"src/web/workspace.py":{"content":"\"\"\"\nWeb workspace management with isolated QtWebEngine profiles\n\"\"\"\n\nimport os\nfrom typing import List, Optional, Callable\nfrom PyQt6.QtCore import Qt, QUrl, pyqtSignal\nfrom PyQt6.QtWidgets import QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QLabel, QPushButton, QFrame\nfrom PyQt6.QtGui import QIcon, QFont\nfrom PyQt6.QtWebEngineWidgets import QWebEngineView\nfrom PyQt6.QtWebEngineCore import QWebEngineProfile, QWebEngineSettings, QWebEnginePage\n\nfrom ..config import CHATGPT_URL\nfrom ..paths import get_workspace_profile_dir\nfrom ..storage.session_manager import TabData, WorkspaceData\nfrom .oauth_handler import OAuthHandler\nfrom .security_interceptor import SecurityInterceptor\n\n\nclass SecurePage(QWebEnginePage):\n    \"\"\"Custom QWebEnginePage that properly handles navigation with security and OAuth checks\"\"\"\n    \n    oauth_notification_requested = pyqtSignal(str)  # message\n    \n    def __init__(self, profile: QWebEngineProfile, parent=None):\n        super().__init__(profile, parent)\n        \n        # Setup security components\n        self.oauth_handler = OAuthHandler(self)\n        self.security_interceptor = SecurityInterceptor(self)\n        \n        # Connect OAuth signals\n        self.oauth_handler.oauth_redirect_requested.connect(self._handle_oauth_redirect)\n    \n    def acceptNavigationRequest(self, url: QUrl, nav_type, is_main_frame: bool) -> bool:\n        \"\"\"Override navigation request handling with security and OAuth checks\"\"\"\n        url_str = url.toString()\n        \n        # Check for dangerous schemes first\n        if self.security_interceptor.should_block_url(url_str):\n            reason = self.security_interceptor.get_block_reason(url_str)\n            self.oauth_notification_requested.emit(f\"🚫 {reason}\")\n            return False\n        \n        # Check for OAuth redirects on main frame navigation\n        if is_main_frame and self.oauth_handler.handle_navigation_request(url_str):\n            # OAuth handler redirected to system browser\n            return False\n        \n        # Allow all other navigation\n        return True\n    \n    def _handle_oauth_redirect(self, url: str, message: str):\n        \"\"\"Handle OAuth redirect notification\"\"\"\n        self.oauth_notification_requested.emit(message)\n    \n    def createWindow(self, window_type):\n        \"\"\"\n        Override popup window creation to ensure all popups use SecurePage with same security checks.\n        Critical security method - ensures OAuth popups can't bypass security.\n        \"\"\"\n        from PyQt6.QtWebEngineCore import QWebEnginePage\n        \n        # Get the URL that will be loaded in the popup (if available)\n        # Note: Qt doesn't always provide the target URL at createWindow time\n        \n        # Create a new secure page with same profile for popup\n        popup_page = SecurePage(self.profile(), self.parent())\n        \n        # Connect popup's OAuth notifications to bubble up \n        popup_page.oauth_notification_requested.connect(\n            self.oauth_notification_requested.emit\n        )\n        \n        # Override the popup's acceptNavigationRequest to handle OAuth immediately\n        original_accept = popup_page.acceptNavigationRequest\n        \n        def popup_navigation_handler(url, nav_type, is_main_frame):\n            \"\"\"Enhanced navigation handler for popup windows\"\"\"\n            url_str = url.toString()\n            \n            # For popups, check OAuth redirects immediately on ANY navigation\n            # (not just main frame like in regular tabs)\n            if self.oauth_handler.handle_navigation_request(url_str):\n                # OAuth handler redirected to system browser\n                # Close the popup since OAuth is handled externally\n                popup_page.deleteLater()\n                return False\n            \n            # Use original security checks for non-OAuth URLs\n            return original_accept(url, nav_type, is_main_frame)\n        \n        # Replace the navigation handler\n        popup_page.acceptNavigationRequest = popup_navigation_handler\n        \n        return popup_page\n\n\nclass ChatGPTWebView(QWebEngineView):\n    \"\"\"Custom web view for ChatGPT with isolated profile\"\"\"\n    \n    oauth_notification_requested = pyqtSignal(str)  # message\n    \n    def __init__(self, workspace_id: int, profile: QWebEngineProfile, parent=None):\n        super().__init__(parent)\n        \n        self.workspace_id = workspace_id\n        \n        # Use shared profile for this workspace\n        self.profile = profile\n        \n        # Create secure page with shared workspace profile\n        self.page_obj = SecurePage(self.profile, self)\n        self.setPage(self.page_obj)\n        \n        # Connect security signals from the secure page\n        self.page_obj.oauth_notification_requested.connect(\n            self.oauth_notification_requested.emit\n        )\n        \n        # Configure for secure operation\n        self._setup_security_settings()\n        \n        # Load ChatGPT\n        self.load(QUrl(CHATGPT_URL))\n    \n    \n    def _setup_security_settings(self):\n        \"\"\"Setup security settings for the web engine\"\"\"\n        # Note: In production builds, we should NOT disable the sandbox\n        # This is only for development/CI environments\n        if os.environ.get(\"QTWEBENGINE_DISABLE_SANDBOX\") == \"1\":\n            # Only in headless CI environments\n            pass\n        \n        # Use default user agent for better compatibility\n    \n    def closeEvent(self, a0):\n        \"\"\"Clean up resources when closing\"\"\"\n        # Clean up page resources\n        if hasattr(self, 'page_obj') and self.page_obj:\n            self.page_obj.deleteLater()\n        \n        # Clear any cached URL history to free memory\n        history = self.history()\n        if history:\n            history.clear()\n        super().closeEvent(a0)\n\n\nclass WorkspaceTabWidget(QTabWidget):\n    \"\"\"Custom tab widget for individual workspace tabs\"\"\"\n    \n    tab_close_requested = pyqtSignal(int)\n    new_tab_requested = pyqtSignal()\n    \n    def __init__(self, workspace_name: str = \"\", notepad_toggle_callback: Optional[Callable] = None, parent=None):\n        super().__init__(parent)\n        self.setTabsClosable(False)  # Remove close buttons as requested\n        self.setMovable(True)\n        self.setDocumentMode(True)\n        \n        self.workspace_name = workspace_name\n        self.notepad_toggle_callback = notepad_toggle_callback\n        \n        self.setup_style()\n        self.setup_corner_widget()\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling to tabs\"\"\"\n        from ..config import COLORS\n        \n        # Clean modern tab styling (30% bigger, similar to reference image)\n        self.setStyleSheet(f\"\"\"\n            QTabWidget::pane {{\n                border: 1px solid {COLORS['accent']};\n                background-color: {COLORS['primary_bg']};\n                border-top: none;\n            }}\n            QTabBar::tab {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                padding: 10px 20px;  /* 30% bigger padding */\n                margin-right: 1px;\n                border-top-left-radius: 8px;\n                border-top-right-radius: 8px;\n                min-width: 160px;  /* 30% bigger minimum width */\n                max-width: 240px;\n                font-family: \"Segoe UI\", Arial, sans-serif;\n                font-size: 11px;\n                font-weight: 500;\n                border: 1px solid transparent;\n                border-bottom: none;\n            }}\n            QTabBar::tab:selected {{\n                background-color: {COLORS['primary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-bottom: 1px solid {COLORS['primary_bg']};\n                color: {COLORS['text']};\n            }}\n            QTabBar::tab:hover:!selected {{\n                background-color: {COLORS['accent']};\n                border: 1px solid {COLORS['accent']};\n                border-bottom: none;\n            }}\n            QTabBar {{\n                qproperty-drawBase: 0;  /* Clean connection between tabs and pane */\n            }}\n        \"\"\")\n    \n    def setup_corner_widget(self):\n        \"\"\"Setup corner widget with workspace name and notepad toggle\"\"\"\n        if not self.workspace_name:\n            return\n            \n        corner_widget = QFrame()\n        corner_widget.setObjectName(\"workspace-corner-widget\")\n        \n        layout = QHBoxLayout(corner_widget)\n        layout.setContentsMargins(8, 2, 8, 2)\n        layout.setSpacing(8)\n        \n        # Workspace name label\n        workspace_label = QLabel(self.workspace_name)\n        workspace_label.setObjectName(\"workspace-name\")\n        workspace_label.setFont(QFont(\"Segoe UI\", 9, QFont.Weight.Bold))\n        layout.addWidget(workspace_label)\n        \n        # Notepad toggle button\n        if self.notepad_toggle_callback:\n            notepad_btn = QPushButton(\"📝\")\n            notepad_btn.setObjectName(\"notepad-toggle\")\n            notepad_btn.setFixedSize(20, 20)\n            notepad_btn.setToolTip(\"Toggle Notepad (Ctrl+Shift+K)\")\n            notepad_btn.clicked.connect(self.notepad_toggle_callback)\n            layout.addWidget(notepad_btn)\n        \n        # Set as corner widget (top-right)\n        self.setCornerWidget(corner_widget, Qt.Corner.TopRightCorner)\n    \n    def update_workspace_name(self, name: str):\n        \"\"\"Update the workspace name displayed in corner widget\"\"\"\n        self.workspace_name = name\n        corner_widget = self.cornerWidget(Qt.Corner.TopRightCorner)\n        if corner_widget:\n            label = corner_widget.findChild(QLabel, \"workspace-name\")\n            if label:\n                label.setText(name)\n\n\nclass WorkspaceWidget(QWidget):\n    \"\"\"Widget representing a single workspace with tabs\"\"\"\n    \n    session_changed = pyqtSignal()\n    notification_requested = pyqtSignal(str)  # message\n    \n    def __init__(self, workspace_id: int, workspace_data: WorkspaceData, notepad_toggle_callback: Optional[Callable] = None, parent=None):\n        super().__init__(parent)\n        self.workspace_id = workspace_id\n        self.workspace_data = workspace_data\n        self.notepad_toggle_callback = notepad_toggle_callback\n        self.web_views: List[ChatGPTWebView] = []\n        self.closed_tabs: List[TabData] = []  # For tab restoration\n        self.max_closed_tabs = 10  # Limit memory usage from closed tabs\n        \n        # Create single shared profile for this workspace\n        self.workspace_profile = self._create_workspace_profile()\n        \n        self.setup_ui()\n        self.restore_session()\n    \n    def _create_workspace_profile(self) -> QWebEngineProfile:\n        \"\"\"Create a single shared profile for this workspace\"\"\"\n        profile_dir = get_workspace_profile_dir(self.workspace_id)\n        profile_name = f\"workspace_{self.workspace_id}\"\n        \n        # Create profile with persistent storage\n        profile = QWebEngineProfile(profile_name, self)\n        profile.setPersistentStoragePath(str(profile_dir))\n        profile.setCachePath(str(profile_dir / \"cache\"))\n        \n        # Enable persistent cookies and storage\n        profile.setPersistentCookiesPolicy(\n            QWebEngineProfile.PersistentCookiesPolicy.AllowPersistentCookies\n        )\n        \n        # OAuth compatibility - allow third-party cookies\n        try:\n            # Only available in Qt 6.6+\n            profile.setThirdPartyCookiePolicy(\n                QWebEngineProfile.ThirdPartyCookiePolicy.AllowAll\n            )\n        except AttributeError:\n            # Fallback for older Qt versions\n            pass\n        \n        # Configure profile settings for optimal ChatGPT experience\n        settings = profile.settings()\n        if settings:\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalStorageEnabled, True)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptEnabled, True)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.PluginsEnabled, False)  # Disable plugins for memory efficiency\n            settings.setAttribute(QWebEngineSettings.WebAttribute.AutoLoadImages, True)\n            # Security settings - restrict local content access\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalContentCanAccessRemoteUrls, False)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalContentCanAccessFileUrls, False)\n            \n            # Memory optimization settings\n            settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptCanOpenWindows, True)  # OAuth needs popups\n            settings.setAttribute(QWebEngineSettings.WebAttribute.WebGLEnabled, False)  # Disable WebGL for memory savings\n            settings.setAttribute(QWebEngineSettings.WebAttribute.Accelerated2dCanvasEnabled, False)  # Reduce GPU memory usage\n        \n        # Configure memory-efficient cache settings\n        # Set cache size limits to prevent excessive memory/disk usage\n        profile.setHttpCacheMaximumSize(50 * 1024 * 1024)  # 50MB cache limit\n        \n        # Set HTTP cache type for better memory management\n        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)\n        \n        # No URL filtering - allow all domains\n        \n        return profile\n    \n    def setup_ui(self):\n        \"\"\"Setup the workspace UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        \n        # Tab widget for web views with workspace info\n        workspace_name = self.workspace_data.name if self.workspace_data else f\"Workspace {self.workspace_id + 1}\"\n        self.tab_widget = WorkspaceTabWidget(workspace_name, self.notepad_toggle_callback)\n        self.tab_widget.tab_close_requested.connect(self.close_tab)\n        self.tab_widget.new_tab_requested.connect(self.new_tab)\n        self.tab_widget.currentChanged.connect(self._on_tab_changed)\n        \n        layout.addWidget(self.tab_widget)\n    \n    def restore_session(self):\n        \"\"\"Restore tabs from workspace data\"\"\"\n        for tab_data in self.workspace_data.tabs:\n            self.add_tab(tab_data.url)\n        \n        # Set active tab\n        if 0 <= self.workspace_data.active_tab < self.tab_widget.count():\n            self.tab_widget.setCurrentIndex(self.workspace_data.active_tab)\n    \n    def add_tab(self, url: str = CHATGPT_URL) -> int:\n        \"\"\"Add a new tab with ChatGPT\"\"\"\n        # Check if we have too many tabs (memory protection)\n        if len(self.web_views) >= 15:  # Limit tabs per workspace for memory efficiency\n            return self.tab_widget.currentIndex()  # Return current tab instead of failing\n            \n        web_view = ChatGPTWebView(self.workspace_id, self.workspace_profile)\n        web_view.load(QUrl(url))\n        \n        self.web_views.append(web_view)\n        tab_index = self.tab_widget.addTab(web_view, \"ChatGPT\")\n        \n        # Connect signals\n        web_view.titleChanged.connect(\n            lambda title, idx=tab_index: self._update_tab_title(idx, title)\n        )\n        web_view.oauth_notification_requested.connect(\n            self.notification_requested.emit\n        )\n        \n        self.session_changed.emit()\n        return tab_index\n    \n    def _update_tab_title(self, index: int, title: str):\n        \"\"\"Update tab title, truncating if too long\"\"\"\n        if index < self.tab_widget.count():\n            truncated_title = title[:30] + \"...\" if len(title) > 30 else title\n            self.tab_widget.setTabText(index, truncated_title)\n    \n    def close_tab(self, index: int):\n        \"\"\"Close a tab and save for restoration\"\"\"\n        if self.tab_widget.count() <= 1:\n            return  # Don't close the last tab\n        \n        web_view = self.tab_widget.widget(index)\n        if isinstance(web_view, ChatGPTWebView):\n            # Save tab data for restoration (with memory limit)\n            self.closed_tabs.append(TabData(\n                url=web_view.url().toString(),\n                title=self.tab_widget.tabText(index)\n            ))\n            \n            # Limit closed tabs to prevent memory leak\n            if len(self.closed_tabs) > self.max_closed_tabs:\n                self.closed_tabs.pop(0)  # Remove oldest closed tab\n            \n            # Remove from lists\n            if web_view in self.web_views:\n                self.web_views.remove(web_view)\n            \n            # Clean up web view resources\n            # Note: Don't clear HTTP cache here as it's shared across workspace tabs\n                \n            # Close tab\n            self.tab_widget.removeTab(index)\n            web_view.deleteLater()\n            \n            self.session_changed.emit()\n    \n    def new_tab(self):\n        \"\"\"Create a new tab\"\"\"\n        index = self.add_tab()\n        self.tab_widget.setCurrentIndex(index)\n    \n    def restore_last_closed_tab(self):\n        \"\"\"Restore the most recently closed tab\"\"\"\n        if self.closed_tabs:\n            tab_data = self.closed_tabs.pop()\n            index = self.add_tab(tab_data.url)\n            self.tab_widget.setCurrentIndex(index)\n    \n    def _on_tab_changed(self, index: int):\n        \"\"\"Handle tab change\"\"\"\n        self.workspace_data.active_tab = index\n        self.session_changed.emit()\n    \n    def get_session_data(self) -> WorkspaceData:\n        \"\"\"Get current session data for this workspace\"\"\"\n        tabs = []\n        for i in range(self.tab_widget.count()):\n            web_view = self.tab_widget.widget(i)\n            if isinstance(web_view, ChatGPTWebView):\n                tabs.append(TabData(\n                    url=web_view.url().toString(),\n                    title=self.tab_widget.tabText(i)\n                ))\n        \n        return WorkspaceData(\n            name=self.workspace_data.name,\n            tabs=tabs,\n            active_tab=self.tab_widget.currentIndex(),\n            notepad_content=self.workspace_data.notepad_content,\n            notepad_visible=self.workspace_data.notepad_visible\n        )\n    \n    def reload_current_tab(self):\n        \"\"\"Reload the current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.reload()\n    \n    def navigate_back(self):\n        \"\"\"Navigate back in current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.back()\n    \n    def navigate_forward(self):\n        \"\"\"Navigate forward in current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.forward()\n    \n    def cleanup(self):\n        \"\"\"Clean up resources\"\"\"\n        # Clear closed tabs to free memory\n        self.closed_tabs.clear()\n        \n        # Clean up web views\n        for web_view in self.web_views:\n            # Force cleanup of web engine resources\n            if hasattr(web_view, 'page_obj') and web_view.page_obj:\n                web_view.page_obj.deleteLater()\n            web_view.deleteLater()\n        self.web_views.clear()\n        \n        # Clean up profile resources\n        if hasattr(self, 'workspace_profile'):\n            self.workspace_profile.clearAllVisitedLinks()\n            self.workspace_profile.clearHttpCache()","size_bytes":19382},"src/ui/notifications.py":{"content":"\"\"\"\nSimple notification system for user feedback\n\"\"\"\n\nfrom PyQt6.QtWidgets import QWidget, QLabel, QVBoxLayout, QGraphicsDropShadowEffect\nfrom PyQt6.QtCore import QTimer, QPropertyAnimation, QEasingCurve, pyqtProperty, Qt\nfrom PyQt6.QtGui import QFont, QColor\nfrom ..config import COLORS\n\n\nclass NotificationWidget(QWidget):\n    \"\"\"Simple notification widget that slides in and auto-hides\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setFixedSize(350, 60)\n        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)\n        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)\n        self._opacity = 0.0\n        \n        self.setup_ui()\n        self.setup_style()\n        self.setup_animation()\n        \n        # Auto-hide timer\n        self.hide_timer = QTimer()\n        self.hide_timer.setSingleShot(True)\n        self.hide_timer.timeout.connect(self.hide_notification)\n    \n    def setup_ui(self):\n        \"\"\"Setup notification UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(15, 10, 15, 10)\n        \n        self.message_label = QLabel()\n        self.message_label.setFont(QFont(\"Arial\", 10))\n        self.message_label.setWordWrap(True)\n        self.message_label.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        layout.addWidget(self.message_label)\n    \n    def setup_style(self):\n        \"\"\"Apply notification styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {COLORS['secondary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 8px;\n            }}\n            QLabel {{\n                color: {COLORS['text']};\n                border: none;\n                background: transparent;\n            }}\n        \"\"\")\n        \n        # Add drop shadow\n        shadow = QGraphicsDropShadowEffect()\n        shadow.setBlurRadius(20)\n        shadow.setColor(QColor(0, 0, 0, 100))\n        shadow.setOffset(0, 3)\n        self.setGraphicsEffect(shadow)\n    \n    def setup_animation(self):\n        \"\"\"Setup fade in/out animation\"\"\"\n        self.animation = QPropertyAnimation(self, b\"opacity\")\n        self.animation.setDuration(300)\n        self.animation.setEasingCurve(QEasingCurve.Type.OutCubic)\n    \n    def get_opacity(self):\n        return self._opacity\n    \n    def set_opacity(self, value):\n        self._opacity = value\n        self.setWindowOpacity(value)\n    \n    opacity = pyqtProperty(float, get_opacity, set_opacity)\n    \n    def show_notification(self, message: str, duration: int = 3000):\n        \"\"\"Show notification with message\"\"\"\n        self.message_label.setText(message)\n        \n        # Position at top-right of parent\n        if self.parent():\n            parent_rect = self.parent().rect()\n            x = parent_rect.width() - self.width() - 20\n            y = 20\n            self.move(x, y)\n        \n        # Animate fade in\n        self.show()\n        try:\n            self.animation.finished.disconnect()  # Clear any previous connections\n        except TypeError:\n            pass  # No connections to disconnect\n        self.animation.setStartValue(0.0)\n        self.animation.setEndValue(0.9)\n        self.animation.start()\n        \n        # Set auto-hide timer\n        self.hide_timer.stop()\n        self.hide_timer.start(duration)\n    \n    def hide_notification(self):\n        \"\"\"Hide notification with fade out\"\"\"\n        try:\n            self.animation.finished.disconnect()\n        except TypeError:\n            pass  # No connections to disconnect\n        self.animation.finished.connect(self.hide)\n        self.animation.setStartValue(self.get_opacity())\n        self.animation.setEndValue(0.0)\n        self.animation.start()\n\n\nclass StatusIndicator(QWidget):\n    \"\"\"Simple status indicator for startup progress\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setFixedHeight(30)\n        self.setup_ui()\n        self.setup_style()\n    \n    def setup_ui(self):\n        \"\"\"Setup status indicator UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(10, 5, 10, 5)\n        \n        self.status_label = QLabel(\"Initializing...\")\n        self.status_label.setFont(QFont(\"Arial\", 9))\n        self.status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        layout.addWidget(self.status_label)\n    \n    def setup_style(self):\n        \"\"\"Apply status indicator styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {COLORS['primary_bg']};\n                border-bottom: 1px solid {COLORS['accent']};\n            }}\n            QLabel {{\n                color: {COLORS['text_dim']};\n                border: none;\n                background: transparent;\n            }}\n        \"\"\")\n    \n    def set_status(self, status: str):\n        \"\"\"Update status message\"\"\"\n        self.status_label.setText(status)\n    \n    def hide_status(self):\n        \"\"\"Hide status indicator\"\"\"\n        self.hide()","size_bytes":5036},"src/web/oauth_handler.py":{"content":"\"\"\"\nLightweight OAuth handler for redirecting authentication to system browser\n\"\"\"\n\nimport webbrowser\nfrom typing import Optional\nfrom urllib.parse import urlparse\nfrom PyQt6.QtCore import QObject, pyqtSignal, QUrl\nfrom PyQt6.QtGui import QDesktopServices\n\n\nclass OAuthHandler(QObject):\n    \"\"\"Minimal OAuth detection and redirection handler\"\"\"\n    \n    oauth_redirect_requested = pyqtSignal(str, str)  # url, message\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # OAuth patterns that should be redirected to system browser\n        self.oauth_patterns = [\n            'accounts.google.com',\n            'oauth2.googleapis.com',\n            'accounts.youtube.com',\n            'myaccount.google.com/oauth',\n            'oauth.googleusercontent.com'\n        ]\n    \n    def should_redirect_to_system_browser(self, url: str) -> bool:\n        \"\"\"\n        Check if URL should be redirected to system browser for OAuth\n        \n        For ChatGPT/OpenAI authentication flows, we keep Google OAuth within the app\n        to maintain session continuity. This prevents the \"invalid session\" error\n        that occurs when OAuth callbacks try to return to a different browser context.\n        \n        Args:\n            url: The URL to check\n            \n        Returns:\n            True if URL should be redirected to system browser\n        \"\"\"\n        # IMPORTANT: For this ChatGPT Browser app, we disable OAuth redirection\n        # to system browser entirely. This ensures that Google OAuth flows for\n        # ChatGPT/OpenAI authentication stay within the same browser context,\n        # preventing session mismatch errors.\n        #\n        # The original OAuth redirection was causing \"Route Error (400 Invalid Session)\"\n        # because the OAuth session was initiated in the embedded WebView but\n        # callbacks were landing in the external system browser, breaking the flow.\n        \n        return False\n    \n    def redirect_to_system_browser(self, url: str) -> bool:\n        \"\"\"\n        Redirect OAuth URL to system browser\n        \n        Args:\n            url: The URL to redirect\n            \n        Returns:\n            True if redirect was successful\n        \"\"\"\n        try:\n            # Use Qt's desktop services for reliable opening\n            qurl = QUrl(url)\n            success = QDesktopServices.openUrl(qurl)\n            \n            if success:\n                message = (\n                    \"🔒 OAuth authentication opened in your default browser \"\n                    \"for security. Complete the sign-in there, then return here.\"\n                )\n                self.oauth_redirect_requested.emit(url, message)\n                return True\n            else:\n                # Fallback to Python webbrowser module\n                webbrowser.open(url, new=2)  # new=2 opens in new tab\n                message = (\n                    \"🔒 OAuth authentication opened in your browser. \"\n                    \"Complete the sign-in there, then return here.\"\n                )\n                self.oauth_redirect_requested.emit(url, message)\n                return True\n                \n        except Exception as e:\n            # If both methods fail, let the navigation continue normally\n            return False\n    \n    def handle_navigation_request(self, url: str) -> bool:\n        \"\"\"\n        Handle navigation request and redirect OAuth if needed\n        \n        Args:\n            url: The requested navigation URL\n            \n        Returns:\n            True if navigation was handled (redirected), False to continue normally\n        \"\"\"\n        if self.should_redirect_to_system_browser(url):\n            return self.redirect_to_system_browser(url)\n        return False","size_bytes":3755},"src/web/security_interceptor.py":{"content":"\"\"\"\nMinimal security interceptor for blocking dangerous URL schemes\n\"\"\"\n\nfrom typing import Set\nfrom PyQt6.QtCore import QObject\n\n\nclass SecurityInterceptor(QObject):\n    \"\"\"Lightweight security interceptor that blocks only dangerous schemes\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # Only block the most dangerous schemes\n        self.blocked_schemes: Set[str] = {\n            'file',        # Local file access\n            'data',        # Data URIs can contain malicious content  \n            'javascript',  # JavaScript execution\n            'vbscript',    # VBScript execution (older browsers)\n            'about'        # about: pages\n        }\n    \n    def should_block_url(self, url: str) -> bool:\n        \"\"\"\n        Check if URL should be blocked based on scheme\n        \n        Args:\n            url: The URL to check\n            \n        Returns:\n            True if URL should be blocked\n        \"\"\"\n        if not url:\n            return False\n            \n        try:\n            # Extract scheme (everything before the first ':')\n            if ':' in url:\n                scheme = url.split(':', 1)[0].lower().strip()\n                \n                # Special case: allow about:blank but block other about: schemes\n                if scheme == 'about':\n                    return not url.lower().strip().startswith('about:blank')\n                \n                return scheme in self.blocked_schemes\n                \n        except Exception:\n            # If URL parsing fails, don't block (be permissive)\n            pass\n            \n        return False\n    \n    def get_block_reason(self, url: str) -> str:\n        \"\"\"\n        Get human-readable reason why URL was blocked\n        \n        Args:\n            url: The blocked URL\n            \n        Returns:\n            Reason for blocking\n        \"\"\"\n        if not url or ':' not in url:\n            return \"Invalid URL format\"\n            \n        try:\n            scheme = url.split(':', 1)[0].lower().strip()\n            \n            if scheme == 'file':\n                return \"File access blocked for security\"\n            elif scheme == 'data':\n                return \"Data URIs blocked for security\" \n            elif scheme == 'javascript':\n                return \"JavaScript execution blocked\"\n            elif scheme == 'vbscript':\n                return \"Script execution blocked\"\n            elif scheme == 'about':\n                if url.lower().strip().startswith('about:blank'):\n                    return \"about:blank allowed but should not reach here\"\n                return \"Internal pages blocked\"\n            else:\n                return f\"Scheme '{scheme}' blocked for security\"\n                \n        except Exception:\n            return \"URL blocked for security\"","size_bytes":2821},"src/ui/animated_widgets.py":{"content":"\"\"\"\nAnimated widgets for smooth transitions\n\"\"\"\n\nfrom PyQt6.QtWidgets import QStackedWidget, QWidget, QGraphicsOpacityEffect, QSplitter\nfrom PyQt6.QtCore import QPropertyAnimation, QEasingCurve, pyqtSignal, QTimer, QObject\n\n\nclass AnimatedStackedWidget(QStackedWidget):\n    \"\"\"QStackedWidget with crossfade animation between pages\"\"\"\n    \n    animation_finished = pyqtSignal()\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.animation_duration = 250  # 250ms as requested\n        self.current_animation = None\n        self.next_index = -1\n        self.preload_timer = QTimer()\n        self.preload_timer.setSingleShot(True)\n        self.preload_timer.timeout.connect(self._start_animation)\n        \n    def setCurrentIndexAnimated(self, index: int):\n        \"\"\"Switch to index with crossfade animation\"\"\"\n        if index == self.currentIndex() or index < 0 or index >= self.count():\n            return\n            \n        # Store the target index\n        self.next_index = index\n        \n        # Start preloading immediately (this gives time for workspace to load)\n        self.preload_timer.start(0)  # Start immediately but allows other operations\n        \n    def _start_animation(self):\n        \"\"\"Start the crossfade animation\"\"\"\n        if self.next_index == -1 or self.current_animation:\n            return\n            \n        current_widget = self.currentWidget()\n        next_widget = self.widget(self.next_index)\n        \n        if not current_widget or not next_widget:\n            self.setCurrentIndex(self.next_index)\n            self.next_index = -1\n            return\n        \n        # Create opacity effects\n        current_effect = QGraphicsOpacityEffect()\n        next_effect = QGraphicsOpacityEffect()\n        \n        current_widget.setGraphicsEffect(current_effect)\n        next_widget.setGraphicsEffect(next_effect)\n        \n        # Set initial opacity values\n        current_effect.setOpacity(1.0)\n        next_effect.setOpacity(0.0)\n        \n        # Make next widget visible and on top\n        next_widget.show()\n        next_widget.raise_()\n        \n        # Create animations\n        self.fade_out_animation = QPropertyAnimation(current_effect, b\"opacity\")\n        self.fade_out_animation.setDuration(self.animation_duration)\n        self.fade_out_animation.setStartValue(1.0)\n        self.fade_out_animation.setEndValue(0.0)\n        self.fade_out_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)\n        \n        self.fade_in_animation = QPropertyAnimation(next_effect, b\"opacity\")\n        self.fade_in_animation.setDuration(self.animation_duration)\n        self.fade_in_animation.setStartValue(0.0)\n        self.fade_in_animation.setEndValue(1.0)\n        self.fade_in_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)\n        \n        # Connect animation finished\n        self.fade_in_animation.finished.connect(self._animation_finished)\n        \n        # Set current animation reference\n        self.current_animation = self.fade_in_animation\n        \n        # Start animations\n        self.fade_out_animation.start()\n        self.fade_in_animation.start()\n        \n        # Switch the actual current index (but visually it's still animating)\n        super().setCurrentIndex(self.next_index)\n        \n    def _animation_finished(self):\n        \"\"\"Clean up after animation completes\"\"\"\n        if self.current_animation:\n            current_widget = self.currentWidget()\n            if current_widget:\n                # Remove opacity effects\n                current_widget.setGraphicsEffect(None)\n            \n            # Clean up previous widget's effect\n            for i in range(self.count()):\n                widget = self.widget(i)\n                if widget and i != self.currentIndex():\n                    widget.setGraphicsEffect(None)\n            \n            self.current_animation = None\n            self.next_index = -1\n            self.animation_finished.emit()\n            \n    def setCurrentIndex(self, index: int):\n        \"\"\"Override to use animated version by default\"\"\"\n        if hasattr(self, 'animation_duration'):  # Check if fully initialized\n            self.setCurrentIndexAnimated(index)\n        else:\n            super().setCurrentIndex(index)\n\n\nclass SplitterAnimator(QObject):\n    \"\"\"Handles smooth animation of QSplitter sizes\"\"\"\n    \n    animation_finished = pyqtSignal()\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.animation = None\n        \n    def animate_to_sizes(self, splitter: QSplitter, target_sizes: list, duration: int = 140):\n        \"\"\"Animate splitter to target sizes\"\"\"\n        if not splitter or self.animation:\n            return\n            \n        # Get current sizes\n        current_sizes = splitter.sizes()\n        if len(current_sizes) != len(target_sizes):\n            # Fallback to instant change if sizes don't match\n            splitter.setSizes(target_sizes)\n            self.animation_finished.emit()\n            return\n        \n        # Create custom animation class that handles splitter sizes\n        class SplitterAnimation(QPropertyAnimation):\n            def __init__(self, splitter, start_sizes, end_sizes, parent=None):\n                # Use a dummy property since we'll override updateCurrentValue\n                super().__init__(splitter, b\"geometry\")\n                self.splitter = splitter\n                self.start_sizes = start_sizes\n                self.end_sizes = end_sizes\n                \n            def updateCurrentValue(self, value):\n                # Interpolate between start and end sizes\n                progress = value.toReal() if hasattr(value, 'toReal') else float(value)\n                current_sizes = []\n                for start, end in zip(self.start_sizes, self.end_sizes):\n                    interpolated = start + (end - start) * progress\n                    current_sizes.append(int(interpolated))\n                self.splitter.setSizes(current_sizes)\n        \n        # Create and configure animation\n        self.animation = SplitterAnimation(splitter, current_sizes, target_sizes, self)\n        self.animation.setDuration(duration)\n        self.animation.setEasingCurve(QEasingCurve.Type.InOutCubic)\n        self.animation.finished.connect(self._on_animation_finished)\n        \n        # Start animation\n        self.animation.start()\n        \n    def _on_animation_finished(self):\n        \"\"\"Clean up after animation\"\"\"\n        self.animation = None\n        self.animation_finished.emit()","size_bytes":6538},"src/ui/memory_manager.py":{"content":"\"\"\"\nIntelligent memory management for workspaces and tabs\n\"\"\"\n\nimport time\nfrom typing import Dict, Set, Optional\nfrom PyQt6.QtCore import QObject, QTimer, pyqtSignal, QUrl\nfrom PyQt6.QtWebEngineWidgets import QWebEngineView\n\n# Configuration\nCOMPRESSION_DELAY_MINUTES = 5  # Compress after 5 minutes of inactivity\nCHECK_INTERVAL_MS = 60000  # Check every minute\n\n\nclass MemoryManager(QObject):\n    \"\"\"Manages memory usage of workspaces and tabs with intelligent compression\"\"\"\n    \n    workspace_needs_loading = pyqtSignal(int)  # workspace_id\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # Track usage timestamps for workspaces and tabs\n        self.workspace_last_used: Dict[int, float] = {}\n        self.tab_last_used: Dict[str, float] = {}  # \"workspace_id:tab_index\" format\n        \n        # Track compressed state\n        self.compressed_workspaces: Set[int] = set()\n        self.compressed_tabs: Set[str] = set()\n        \n        # Setup cleanup timer\n        self.cleanup_timer = QTimer(self)\n        self.cleanup_timer.timeout.connect(self._cleanup_unused_memory)\n        self.cleanup_timer.start(CHECK_INTERVAL_MS)\n    \n    def mark_workspace_used(self, workspace_id: int):\n        \"\"\"Mark a workspace as recently used\"\"\"\n        self.workspace_last_used[workspace_id] = time.time()\n        \n        # If workspace was compressed, mark it for loading\n        if workspace_id in self.compressed_workspaces:\n            self.compressed_workspaces.remove(workspace_id)\n            self.workspace_needs_loading.emit(workspace_id)\n    \n    def mark_tab_used(self, workspace_id: int, tab_index: int):\n        \"\"\"Mark a specific tab as recently used\"\"\"\n        tab_key = f\"{workspace_id}:{tab_index}\"\n        self.tab_last_used[tab_key] = time.time()\n        \n        # If tab was compressed, remove from compressed set\n        self.compressed_tabs.discard(tab_key)\n    \n    def is_workspace_compressed(self, workspace_id: int) -> bool:\n        \"\"\"Check if a workspace is currently compressed\"\"\"\n        return workspace_id in self.compressed_workspaces\n    \n    def is_tab_compressed(self, workspace_id: int, tab_index: int) -> bool:\n        \"\"\"Check if a tab is currently compressed\"\"\"\n        tab_key = f\"{workspace_id}:{tab_index}\"\n        return tab_key in self.compressed_tabs\n    \n    def compress_workspace(self, workspace_id: int, workspace_widget):\n        \"\"\"Compress a workspace by suspending web views\"\"\"\n        if workspace_id in self.compressed_workspaces:\n            return\n            \n        # Suspend all tabs in this workspace\n        tab_widget = workspace_widget.tab_widget\n        for i in range(tab_widget.count()):\n            web_view = tab_widget.widget(i)\n            if isinstance(web_view, QWebEngineView):\n                # Store the URL and clear the page to free memory\n                current_url = web_view.url().toString()\n                if hasattr(web_view, '_original_url'):\n                    web_view._original_url = current_url\n                else:\n                    web_view._original_url = current_url\n                \n                # Navigate to about:blank to free memory\n                web_view.setUrl(QUrl(\"about:blank\"))\n        \n        self.compressed_workspaces.add(workspace_id)\n    \n    def restore_workspace(self, workspace_id: int, workspace_widget):\n        \"\"\"Restore a compressed workspace\"\"\"\n        if workspace_id not in self.compressed_workspaces:\n            return\n            \n        # Restore all tabs in this workspace\n        tab_widget = workspace_widget.tab_widget\n        for i in range(tab_widget.count()):\n            web_view = tab_widget.widget(i)\n            if isinstance(web_view, QWebEngineView) and hasattr(web_view, '_original_url'):\n                # Restore the original URL\n                web_view.setUrl(QUrl(web_view._original_url))\n        \n        self.compressed_workspaces.remove(workspace_id)\n    \n    def _cleanup_unused_memory(self):\n        \"\"\"Check for unused workspaces/tabs and compress them\"\"\"\n        current_time = time.time()\n        threshold_seconds = COMPRESSION_DELAY_MINUTES * 60\n        \n        # Find workspaces that haven't been used recently\n        workspaces_to_compress = []\n        for workspace_id, last_used in self.workspace_last_used.items():\n            if current_time - last_used > threshold_seconds:\n                if workspace_id not in self.compressed_workspaces:\n                    workspaces_to_compress.append(workspace_id)\n        \n        # Emit signals for workspaces that need compression\n        # The main window will handle the actual compression\n        for workspace_id in workspaces_to_compress:\n            self.compress_workspace_signal.emit(workspace_id)\n    \n    # Signal for main window to handle compression\n    compress_workspace_signal = pyqtSignal(int)","size_bytes":4865}},"version":1}