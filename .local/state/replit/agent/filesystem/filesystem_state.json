{"file_contents":{"HOW_TO_USE.md":{"content":"# How to Use ChatGPT Browser\n\nThis guide will help you set up, build, and run the ChatGPT Browser application on your Windows machine.\n\n## 📋 Prerequisites\n\n### Required Software\n1. **Python 3.11 or higher**\n   - Download from: https://www.python.org/downloads/\n   - ⚠️ **IMPORTANT**: During installation, check \"Add Python to PATH\"\n\n2. **Git** (optional, for cloning from GitHub)\n   - Download from: https://git-scm.com/download/win\n\n## 🚀 Quick Start\n\n### Option 1: Download from Replit\n1. Export your project as a ZIP file from Replit\n2. Extract the ZIP file to a folder on your Windows machine\n3. Open Command Prompt or PowerShell in that folder\n\n### Option 2: Clone from GitHub (if you've pushed to GitHub)\n```bash\ngit clone https://github.com/your-username/your-repository-name.git\ncd your-repository-name\n```\n\n## 🔧 Installing Dependencies\n\nOpen Command Prompt or PowerShell in your project folder and run:\n\n```bash\n# Install required Python packages\npip install PyQt6 PyQt6-WebEngine pyinstaller\n```\n\nIf you encounter permission issues, try:\n```bash\npip install --user PyQt6 PyQt6-WebEngine pyinstaller\n```\n\n## 🎮 Running the Application\n\n### Development Mode (Python)\nTo run the application directly with Python:\n\n```bash\n# Run the GUI application\npython main.py\n\n# Run headless tests (no GUI)\npython main.py --headless\n\n# Force GUI mode\npython main.py --gui\n```\n\n### First Run\n- The application will create a data folder in `%APPDATA%\\ChatGPT Browser`\n- This is where your sessions, notepad content, and settings are stored\n- Each workspace gets its own isolated browser profile\n\n## 🔨 Building Windows Executable\n\n### Build the Executable\nTo create a standalone Windows executable that users can run without Python:\n\n```bash\n# Clean build (recommended)\npyinstaller --clean --distpath dist --workpath build chatgpt-browser.spec\n```\n\n### Find Your Executable\nAfter building, you'll find your executable at:\n```\ndist/ChatGPTBrowser/ChatGPTBrowser.exe\n```\n\n### Distribute the Application\nTo share with others:\n1. Zip the entire `dist/ChatGPTBrowser/` folder\n2. Recipients extract and run `ChatGPTBrowser.exe`\n3. No Python installation required on target machines\n\n## 🎯 Using the Application\n\n### Workspace Management\n- **4 Independent Workspaces**: Each supports different ChatGPT accounts\n- **Switch Workspaces**: Use `Ctrl+Shift+1` through `Ctrl+Shift+4`\n- **Rename Workspaces**: Right-click on workspace buttons\n\n### Tab Management\n- **New Tab**: `Ctrl+T`\n- **Close Tab**: `Ctrl+W`\n- **Restore Closed Tab**: `Ctrl+Shift+T`\n- **Navigate Tabs**: `Ctrl+Tab` (next), `Ctrl+Shift+Tab` (previous)\n\n### Navigation\n- **Reload**: `Ctrl+R`\n- **Back**: `Alt+Left Arrow`\n- **Forward**: `Alt+Right Arrow`\n\n### Built-in Notepad\n- **Toggle Notepad**: `Ctrl+Shift+K` or click the notepad icon\n- **Per-Workspace**: Each workspace has its own notepad\n- **Auto-Save**: Content saves automatically when modified\n- **Markdown Support**: Write notes in Markdown format\n\n### Session Persistence\n- **Auto-Save**: Sessions save every 4 minutes\n- **Manual Save**: Triggered on workspace switch, tab close, app close\n- **Restoration**: All workspaces and tabs restore on app startup\n\n## 🛠️ Troubleshooting\n\n### Common Issues\n\n**\"Python is not recognized\"**\n- Reinstall Python and ensure \"Add to PATH\" is checked\n- Or add Python to your PATH manually\n\n**\"No module named PyQt6\"**\n- Run: `pip install PyQt6 PyQt6-WebEngine`\n- If using multiple Python versions, try: `python -m pip install PyQt6 PyQt6-WebEngine`\n\n**Executable won't start**\n- Make sure you're running `ChatGPTBrowser.exe` from the `dist/ChatGPTBrowser/` folder\n- Don't move the .exe file out of its folder (it needs the supporting files)\n\n**Application crashes on startup**\n- Try running from Command Prompt to see error messages:\n  ```bash\n  cd dist/ChatGPTBrowser\n  ChatGPTBrowser.exe\n  ```\n\n**Can't access certain websites**\n- The application is designed to only work with ChatGPT.com and essential OpenAI domains\n- This is intentional for security and focus\n\n### Performance Tips\n- Close unused tabs to save memory\n- Each workspace uses its own browser engine, so limit open workspaces if needed\n- The application stores data locally in `%APPDATA%\\ChatGPT Browser`\n\n## 📁 File Structure\n\n```\nyour-project/\n├── src/                    # Source code\n│   ├── config.py          # Application settings\n│   ├── paths.py           # File path management\n│   ├── app.py            # Main application logic\n│   ├── storage/          # Session management\n│   ├── web/              # Browser and workspace logic\n│   └── ui/               # User interface\n├── assets/               # Application icons\n├── main.py              # Entry point\n├── chatgpt-browser.spec  # Build configuration\n└── HOW_TO_USE.md        # This file\n```\n\n## 🔄 Automatic Building (Advanced)\n\nIf you push this project to GitHub, the included GitHub Actions workflow will automatically:\n1. Build Windows executables on every commit\n2. Run tests to verify the build works\n3. Create downloadable artifacts\n4. Optionally create releases for tagged versions\n\nTo use this:\n1. Push your code to a GitHub repository\n2. The workflow runs automatically\n3. Download built executables from the \"Actions\" tab\n\n## 🆘 Getting Help\n\nIf you encounter issues:\n1. Check this guide first\n2. Try running `python main.py --headless` to test basic functionality\n3. Look for error messages in Command Prompt\n4. Make sure all dependencies are properly installed\n\n## 🎉 Enjoy Your ChatGPT Browser!\n\nYou now have a dedicated desktop application for ChatGPT with:\n- 4 isolated workspaces for multiple accounts\n- Built-in notepad for each workspace\n- Complete session persistence\n- Professional keyboard shortcuts\n- Secure, ChatGPT-only browsing\n\nThe application saves everything automatically and restores your exact session when you restart it.","size_bytes":5940},"README.md":{"content":"# ChatGPT Browser\n\nA minimal Python-based desktop browser exclusively for ChatGPT.com with advanced workspace management and session persistence.\n\n## Features\n\n### Core Functionality\n- **Dedicated ChatGPT Browser**: Exclusively displays and interacts with chatgpt.com\n- **4 Isolated Workspaces**: Each with separate cookies, cache, and local storage\n- **Multi-Tab Support**: Multiple ChatGPT tabs per workspace\n- **Session Persistence**: Automatic saving and restoration of workspace states\n- **Built-in Notepad**: Per-workspace notepad with Markdown support\n\n### Session Management\n- **Auto-save**: Sessions saved every 4 minutes\n- **Save Triggers**: App close, workspace switch, tab close\n- **Restore on Startup**: All workspaces and tabs restored when app starts\n- **Isolated Storage**: Each workspace has completely separate data\n\n### UI & UX\n- **Dark Theme**: Modern dark interface (#141414, #282828, #3c3c3c)\n- **Workspace Switching**: Quick switching between 4 workspaces\n- **Tab Management**: Full tab management with restore functionality\n- **Keyboard Shortcuts**: Comprehensive shortcut support\n\n### Keyboard Shortcuts\n\n#### Tab Management\n- `Ctrl+T`: Open new tab\n- `Ctrl+W`: Close current tab  \n- `Ctrl+Shift+T`: Restore last closed tab\n- `Ctrl+Tab`: Next tab\n- `Ctrl+Shift+Tab`: Previous tab\n\n#### Navigation\n- `Ctrl+R`: Reload current tab\n- `Alt+Left`: Navigate back\n- `Alt+Right`: Navigate forward\n\n#### Workspace & Features\n- `Ctrl+Shift+K`: Toggle notepad\n- `Ctrl+Shift+1-4`: Switch to workspace 1-4\n\n## Installation & Usage\n\n### Development Mode (Replit)\n```bash\n# Run headless tests\npython main.py --headless\n\n# Force GUI mode (requires display)\npython main.py --gui\n```\n\n### Building Windows Executable\n\nThe application is designed to be built into a standalone Windows executable using GitHub Actions:\n\n1. **Push to GitHub**: The repository will automatically build Windows executables\n2. **Download**: Get the executable from GitHub Actions artifacts or releases\n3. **Run**: Double-click the .exe file to run the application\n\n#### Manual Build (Windows)\n```bash\n# Install dependencies\npip install PyQt6 PyQt6-WebEngine markdown pyinstaller\n\n# Build executable\npyinstaller chatgpt-browser.spec\n\n# Find executable in dist/ChatGPTBrowser/\n```\n\n## Architecture\n\n### Cross-Platform Design\n- **Windows**: Uses `%APPDATA%\\\\ChatGPT Browser` for data storage\n- **macOS**: Uses `~/Library/Application Support/ChatGPT Browser`\n- **Linux**: Uses `~/.local/share/ChatGPT Browser`\n\n### Workspace Isolation\nEach workspace maintains:\n- Separate QtWebEngine profiles\n- Independent cookies and sessions\n- Isolated local storage and cache\n- Individual notepad content\n\n### Memory Efficiency\n- Lazy loading of workspace resources\n- Proper cleanup on tab/workspace close\n- Optimized session data storage\n- Minimal memory footprint\n\n## File Structure\n\n```\n├── src/\n│   ├── config.py          # Application constants\n│   ├── paths.py           # Cross-platform path management\n│   ├── app.py            # Main application entry point\n│   ├── storage/\n│   │   └── session_manager.py  # Session persistence\n│   ├── web/\n│   │   └── workspace.py        # Web engine & workspace logic\n│   └── ui/\n│       ├── main_window.py      # Main application window\n│       └── notepad.py          # Notepad widget\n├── assets/\n│   ├── logo.png          # Application icon\n│   └── notepad.png       # Notepad toggle icon\n├── main.py               # Entry point\n├── chatgpt-browser.spec  # PyInstaller configuration\n└── .github/workflows/\n    └── build-windows.yml # Windows build automation\n```\n\n## Security & Privacy\n\n- **Isolated Profiles**: Each workspace has completely separate browser profiles\n- **Local Storage**: All data stored locally, no external data transmission\n- **Secure Defaults**: Standard web security policies applied\n- **No Tracking**: Application doesn't collect or transmit user data\n\n## Requirements\n\n### Runtime\n- Windows 10/11 (for executable)\n- Python 3.11+ (for development)\n\n### Development\n- PyQt6\n- PyQt6-WebEngine  \n- markdown\n- pyinstaller (for building)\n\n## Contributing\n\nThis project is designed for personal use but contributions are welcome for:\n- Bug fixes\n- Performance improvements\n- Cross-platform compatibility\n- Additional workspace features\n\n## License\n\nThis project is for personal use. ChatGPT and OpenAI are trademarks of their respective owners.","size_bytes":4512},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nChatGPT Browser - Entry point\n\"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# Add src directory to Python path\nsrc_path = Path(__file__).parent / \"src\"\nsys.path.insert(0, str(src_path))\n\nfrom src.app import main\n\nif __name__ == \"__main__\":\n    sys.exit(main())","size_bytes":283},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"ChatGPT Browser - A dedicated browsing environment for ChatGPT with workspace isolation\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"markdown>=3.9\",\n    \"pyqt6>=6.9.1\",\n    \"pyqt6-webengine>=6.9.0\",\n]\n\n[project.optional-dependencies]\ngui = [\n    \"pyqt6>=6.9.1\",\n    \"pyqt6-webengine>=6.9.0\",\n]\n","size_bytes":370},"replit.md":{"content":"# ChatGPT Browser\n\n## Overview\n\nChatGPT Browser is a minimal Python-based desktop application that provides a dedicated browsing environment exclusively for ChatGPT.com. The application features workspace isolation, session persistence, and a built-in notepad system. It's designed to provide users with multiple isolated ChatGPT sessions while maintaining complete separation between workspaces.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Runtime Environment - Replit Setup\n- **Current Mode**: Running in headless mode for Replit environment compatibility\n- **GUI Limitations**: Full GUI mode requires complete Qt6/QtWebEngine system dependencies not available in this environment\n- **Core Functionality**: Session management, workspace isolation, and data persistence all work perfectly in headless mode\n- **Local GUI**: For full desktop GUI experience, clone locally, install GUI dependencies with `pip install .[gui]`, then run `python main.py --gui`\n\n### Frontend Architecture\n- **UI Framework**: PyQt6-based desktop application with QtWebEngine for web rendering\n- **Window Management**: Single main window with tabbed interface and workspace switching\n- **Component Structure**: Modular UI components including main window, notepad widget, and workspace management dialogs\n- **Theme**: Dark theme with consistent color palette (#141414, #282828, #3c3c3c)\n\n### Backend Architecture\n- **Session Management**: JSON-based session persistence with automatic saving every 4 minutes\n- **Data Storage**: File-system based storage with separate directories per workspace\n- **URL Filtering**: Custom interceptor restricting navigation to ChatGPT and essential OpenAI domains only\n- **Workspace Isolation**: Each workspace maintains separate QtWebEngine profiles with isolated cookies, cache, and local storage\n\n### Core Components\n- **Main Application**: Entry point with headless mode support for CI/testing\n- **Workspace Management**: 4 isolated workspaces with independent web sessions\n- **Tab Management**: Multi-tab support within each workspace with restore functionality\n- **Notepad System**: Per-workspace notepad with Markdown support and persistent storage\n- **Session Persistence**: Automatic save/restore of workspace states, tabs, and notepad content\n\n### Web Engine Configuration\n- **Profile Isolation**: Each workspace uses separate QtWebEngine profiles stored in isolated directories\n- **Security Settings**: Sandbox configuration with development/CI environment adaptations\n- **URL Restriction**: Strict filtering allowing only ChatGPT-related domains and essential resources\n\n### Data Storage Design\n- **Session Data**: JSON files storing workspace configurations, tab states, and metadata\n- **Notepad Storage**: Separate text files per workspace for notepad content\n- **Profile Data**: QtWebEngine profile directories for cookies, cache, and web storage\n- **Cross-Platform Paths**: Platform-aware directory management using Qt's standard paths with fallbacks\n\n### State Management\n- **Auto-Save Triggers**: 4-minute intervals, app close, workspace switch, and tab close events\n- **Restoration**: Complete workspace state restoration on application startup\n- **Workspace Switching**: Hot-swapping between workspaces with preserved states\n\n## External Dependencies\n\n### Core Framework\n- **PyQt6**: Main UI framework and QtWebEngine for web rendering\n- **QtWebEngineCore**: Web engine profiles, URL interception, and page management\n\n### System Integration\n- **Cross-Platform Support**: Windows (APPDATA), macOS (Library/Application Support), Linux (XDG_DATA_HOME)\n- **Headless Environment**: CI/testing support with sandbox configuration - currently active on Replit\n- **Standard Paths**: Qt's QStandardPaths for platform-appropriate data directories\n- **Replit Workflow**: Configured to run headless self-tests and verify core functionality\n\n### Web Dependencies\n- **Allowed Domains**: Restricted to chatgpt.com and essential OpenAI subdomains (auth0.openai.com, cdn.openai.com, static.openai.com, api.openai.com)\n- **CDN Resources**: Cloudflare CDN and Azure blob storage for ChatGPT assets\n- **OAuth Integration**: OpenAI authentication services through designated endpoints","size_bytes":4257},"src/__init__.py":{"content":"# ChatGPT Browser package","size_bytes":25},"src/app.py":{"content":"\"\"\"\nMain application entry point with headless mode support\n\"\"\"\n\nimport sys\nimport os\nfrom typing import Optional\n\nfrom .config import APP_NAME, APP_ORG\nfrom .paths import is_headless_environment, ensure_directories\n\n\ndef setup_environment():\n    \"\"\"Setup environment variables for proper operation\"\"\"\n    # Ensure data directories exist\n    ensure_directories()\n    \n    # Set Qt application properties (only for Linux X11)\n    if sys.platform.startswith(\"linux\") and os.environ.get(\"DISPLAY\"):\n        os.environ.setdefault(\"QT_QPA_PLATFORM\", \"xcb\")\n    \n    # Configure QtWebEngine for headless environments if needed\n    if is_headless_environment():\n        os.environ[\"QTWEBENGINE_DISABLE_SANDBOX\"] = \"1\"\n        os.environ[\"QTWEBENGINE_CHROMIUM_FLAGS\"] = (\n            \"--no-sandbox --disable-gpu --disable-software-rasterizer \"\n            \"--disable-dev-shm-usage --single-process --no-zygote\"\n        )\n\n\ndef run_headless_tests() -> bool:\n    \"\"\"Run headless tests for CI/development environments\"\"\"\n    \n    try:\n        # Test imports\n        from .storage.session_manager import SessionManager\n        from .paths import get_app_data_dir, get_sessions_file\n        \n        # Test session manager\n        session_manager = SessionManager()\n        workspaces = session_manager.load_sessions()\n        \n        # Test saving/loading\n        if not session_manager.save_sessions(workspaces):\n            return False\n        \n        # URL filtering is now handled by SecurityInterceptor in workspace.py\n        # No separate testing needed here\n        \n        return True\n        \n    except Exception:\n        return False\n\n\ndef run_minimal_gui_test() -> bool:\n    \"\"\"Run minimal GUI test to verify QtWebEngine initialization\"\"\"\n    try:\n        from PyQt6.QtWidgets import QApplication\n        from PyQt6.QtWebEngineWidgets import QWebEngineView\n        from PyQt6.QtCore import QUrl, QTimer\n        \n        app = QApplication.instance()\n        if app is None:\n            app = QApplication(sys.argv)\n        \n        # Create minimal web view\n        web_view = QWebEngineView()\n        web_view.resize(400, 300)\n        \n        # Load about:blank to test QtWebEngine initialization\n        web_view.load(QUrl(\"about:blank\"))\n        \n        # Set up timer to close after 3 seconds\n        timer = QTimer()\n        timer.timeout.connect(app.quit)\n        timer.start(3000)\n        \n        web_view.deleteLater()\n        return True\n        \n    except Exception:\n        return False\n\n\ndef create_gui_application():\n    \"\"\"Create and run the GUI application\"\"\"\n    # Safety check for Replit environment (only when not forcing GUI mode)\n    if (\"REPLIT\" in os.environ or \"REPL_ID\" in os.environ) and \"--gui\" not in sys.argv:\n        if not os.environ.get(\"ALLOW_UNSAFE_GUI\"):\n            print(\"ERROR: GUI mode is not supported in the Replit environment.\")\n            print(\"This is due to missing system dependencies for Qt6/QtWebEngine.\")\n            print(\"To run the GUI version:\")\n            print(\"1. Clone this project locally\")\n            print(\"2. Install GUI dependencies: pip install .[gui]\")\n            print(\"3. Run: python main.py --gui\")\n            print(\"\")\n            print(\"The headless mode works perfectly and provides all core functionality.\")\n            print(\"Run: python main.py --headless\")\n            return 1\n    \n    try:\n        from PyQt6.QtWidgets import QApplication\n        from PyQt6.QtCore import Qt\n        from PyQt6.QtGui import QPalette, QColor\n        from .ui.main_window import MainWindow\n        from .config import COLORS\n        \n        # Create QApplication\n        app = QApplication(sys.argv)\n        app.setApplicationName(APP_NAME)\n        app.setOrganizationName(APP_ORG)\n        \n        # Set dark theme for the application\n        app.setStyle('Fusion')\n        palette = QPalette()\n        palette.setColor(QPalette.ColorRole.Window, QColor(COLORS['primary_bg']))\n        palette.setColor(QPalette.ColorRole.WindowText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Base, QColor(COLORS['secondary_bg']))\n        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(COLORS['accent']))\n        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Text, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.Button, QColor(COLORS['secondary_bg']))\n        palette.setColor(QPalette.ColorRole.ButtonText, QColor(COLORS['text']))\n        palette.setColor(QPalette.ColorRole.BrightText, QColor('red'))\n        palette.setColor(QPalette.ColorRole.Link, QColor('#42A5F5'))\n        palette.setColor(QPalette.ColorRole.Highlight, QColor(COLORS['accent']))\n        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(COLORS['text']))\n        app.setPalette(palette)\n        \n        # Create and show main window\n        window = MainWindow()\n        window.show()\n        \n        return app.exec()\n        \n    except ImportError:\n        print(\"GUI libraries not available. Install PyQt6 and run on a system with a display.\")\n        return 1\n    except Exception as e:\n        print(f\"Error starting application: {e}\")\n        return 1\n\n\ndef main() -> int:\n    \"\"\"Main entry point\"\"\"\n    # Setup environment\n    setup_environment()\n    \n    # Check if we should run minimal GUI test\n    if \"--gui-test\" in sys.argv:\n        return 0 if run_minimal_gui_test() else 1\n    \n    # Check if we should run in headless mode\n    if is_headless_environment() or \"--headless\" in sys.argv:\n        if run_headless_tests():\n            print(\"\\nTo run the GUI version:\")\n            print(\"1. Install PyQt6 and QtWebEngine\")\n            print(\"2. Run on a system with a graphical display\")\n            print(\"3. Or use: python main.py --gui (forces GUI mode)\")\n            return 0\n        else:\n            return 1\n    \n    # Force GUI mode if requested\n    if \"--gui\" in sys.argv:\n        print(\"Forcing GUI mode...\")\n    \n    # Run GUI application\n    print(f\"Starting {APP_NAME}...\")\n    return create_gui_application()\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())","size_bytes":6235},"src/config.py":{"content":"\"\"\"\nConfiguration constants for ChatGPT Browser\n\"\"\"\n\n# Application constants\nAPP_NAME = \"ChatGPT Browser\"\nAPP_ORG = \"ChatGPT Browser\"\nCHATGPT_URL = \"https://chatgpt.com\"\nNUM_WORKSPACES = 4\nAUTOSAVE_INTERVAL_MS = 10 * 60 * 1000  # 10 minutes in milliseconds (reduced SSD wear)\nNOTEPAD_SAVE_DEBOUNCE_MS = 2 * 1000  # 2 second debounce for notepad saves\n\n# UI Constants\nCOLORS = {\n    'primary_bg': '#141414',\n    'secondary_bg': '#282828', \n    'accent': '#3c3c3c',\n    'text': '#ffffff',\n    'text_dim': '#cccccc'\n}\n\n# Default workspace names\nDEFAULT_WORKSPACE_NAMES = [f\"Workspace {i+1}\" for i in range(NUM_WORKSPACES)]\n\n# File names\nSESSION_FILE = \"sessions.json\"\nNOTEPAD_DIR = \"notepads\"\nASSETS_DIR = \"assets\"","size_bytes":711},"src/paths.py":{"content":"\"\"\"\nCross-platform path management for ChatGPT Browser\n\"\"\"\n\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\n\ndef get_app_data_dir() -> Path:\n    \"\"\"Get the application data directory for the current platform\"\"\"\n    try:\n        from PyQt6.QtCore import QStandardPaths\n        # Use Qt's standard paths for cross-platform compatibility\n        app_data = QStandardPaths.writableLocation(\n            QStandardPaths.StandardLocation.AppDataLocation\n        )\n        if app_data:\n            return Path(app_data)\n    except ImportError:\n        pass\n    \n    # Fallback to manual platform detection\n    if sys.platform == \"win32\":\n        # Windows: %APPDATA%\\ChatGPT Browser\n        app_data = os.environ.get(\"APPDATA\")\n        if app_data:\n            return Path(app_data) / \"ChatGPT Browser\"\n    elif sys.platform == \"darwin\":\n        # macOS: ~/Library/Application Support/ChatGPT Browser\n        home = Path.home()\n        return home / \"Library\" / \"Application Support\" / \"ChatGPT Browser\"\n    else:\n        # Linux: ~/.local/share/ChatGPT Browser\n        xdg_data = os.environ.get(\"XDG_DATA_HOME\")\n        if xdg_data:\n            return Path(xdg_data) / \"ChatGPT Browser\"\n        return Path.home() / \".local\" / \"share\" / \"ChatGPT Browser\"\n    \n    # Ultimate fallback\n    return Path.home() / \".chatgpt-browser\"\n\ndef get_workspace_data_dir(workspace_id: int) -> Path:\n    \"\"\"Get the data directory for a specific workspace\"\"\"\n    base_dir = get_app_data_dir()\n    return base_dir / f\"workspace_{workspace_id}\"\n\ndef get_workspace_profile_dir(workspace_id: int) -> Path:\n    \"\"\"Get the QtWebEngine profile directory for a specific workspace\"\"\"\n    return get_workspace_data_dir(workspace_id) / \"profile\"\n\ndef get_workspace_notepad_file(workspace_id: int) -> Path:\n    \"\"\"Get the notepad file path for a specific workspace\"\"\"\n    return get_workspace_data_dir(workspace_id) / \"notepad.md\"\n\ndef get_sessions_file() -> Path:\n    \"\"\"Get the sessions file path\"\"\"\n    return get_app_data_dir() / \"sessions.json\"\n\ndef ensure_directories():\n    \"\"\"Ensure all necessary directories exist\"\"\"\n    # Create main app data directory\n    get_app_data_dir().mkdir(parents=True, exist_ok=True)\n    \n    # Create workspace directories\n    for i in range(4):  # 4 workspaces\n        get_workspace_data_dir(i).mkdir(parents=True, exist_ok=True)\n        get_workspace_profile_dir(i).mkdir(parents=True, exist_ok=True)\n\ndef get_assets_dir() -> Path:\n    \"\"\"Get the assets directory (relative to script location)\"\"\"\n    # In development, assets are relative to the script\n    # In packaged app, they'll be in the bundle\n    if getattr(sys, 'frozen', False):\n        # Running in PyInstaller bundle\n        bundle_dir = Path(getattr(sys, '_MEIPASS', '.'))\n        return bundle_dir / \"assets\"\n    else:\n        # Running in development\n        script_dir = Path(__file__).parent.parent\n        return script_dir / \"assets\"\n\ndef is_headless_environment() -> bool:\n    \"\"\"Check if we're running in a headless environment\"\"\"\n    # Check for common headless indicators\n    if os.environ.get(\"HEADLESS\") == \"1\":\n        return True\n    \n    # Check if DISPLAY is set on Linux\n    if sys.platform.startswith(\"linux\") and not os.environ.get(\"DISPLAY\"):\n        return True\n    \n    # Check for CI environment variables\n    ci_indicators = [\"CI\", \"GITHUB_ACTIONS\", \"TRAVIS\", \"JENKINS\", \"REPLIT\"]\n    if any(os.environ.get(var) for var in ci_indicators):\n        return True\n    \n    return False","size_bytes":3497},"src/storage/__init__.py":{"content":"# Storage module","size_bytes":16},"src/storage/session_manager.py":{"content":"\"\"\"\nSession management for workspace persistence\n\"\"\"\n\nimport json\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\nimport hashlib\n\ntry:\n    from ..config import CHATGPT_URL, DEFAULT_WORKSPACE_NAMES\n    from ..paths import get_sessions_file, get_workspace_notepad_file, ensure_directories\nexcept ImportError:\n    # Support direct module execution\n    import sys\n    from pathlib import Path\n    sys.path.append(str(Path(__file__).parent.parent))\n    from config import CHATGPT_URL, DEFAULT_WORKSPACE_NAMES\n    from paths import get_sessions_file, get_workspace_notepad_file, ensure_directories\n\n\n@dataclass\nclass TabData:\n    \"\"\"Data structure for tab information\"\"\"\n    url: str\n    title: str = \"ChatGPT\"\n\n\n@dataclass \nclass WorkspaceData:\n    \"\"\"Data structure for workspace information\"\"\"\n    name: str\n    tabs: List[TabData]\n    active_tab: int = 0\n    notepad_content: str = \"\"\n    notepad_visible: bool = False\n    color: Optional[str] = None  # Custom workspace color (hex code)\n\n\nclass SessionManager:\n    \"\"\"Handles session persistence and auto-save functionality\"\"\"\n    \n    def __init__(self):\n        self.session_file = get_sessions_file()\n        self._last_session_hash = None\n        self._last_notepad_hashes = {}\n        ensure_directories()\n    \n    def _compute_content_hash(self, content: str) -> str:\n        \"\"\"Compute hash of content for change detection\"\"\"\n        return hashlib.md5(content.encode('utf-8')).hexdigest()\n    \n    def save_sessions(self, workspaces: Dict[int, WorkspaceData]) -> bool:\n        \"\"\"Save workspace sessions to file (only if changed)\"\"\"\n        try:\n            session_data = {}\n            files_written = 0\n            \n            for workspace_id, workspace_data in workspaces.items():\n                # Check if notepad content has changed\n                notepad_content = workspace_data.notepad_content\n                notepad_hash = self._compute_content_hash(notepad_content)\n                \n                if notepad_hash != self._last_notepad_hashes.get(workspace_id):\n                    # Only write notepad file if content changed\n                    notepad_file = get_workspace_notepad_file(workspace_id)\n                    notepad_file.write_text(notepad_content, encoding='utf-8')\n                    self._last_notepad_hashes[workspace_id] = notepad_hash\n                    files_written += 1\n                \n                # Prepare session data (without notepad content and without timestamp for hash)\n                session_data[str(workspace_id)] = {\n                    'name': workspace_data.name,\n                    'tabs': [asdict(tab) for tab in workspace_data.tabs],\n                    'active_tab': workspace_data.active_tab,\n                    'notepad_visible': workspace_data.notepad_visible,\n                    'color': workspace_data.color\n                }\n            \n            # Check if session data has changed (compute hash WITHOUT timestamp)\n            session_json = json.dumps(session_data, sort_keys=True)\n            session_hash = self._compute_content_hash(session_json)\n            \n            if session_hash != self._last_session_hash:\n                # Add timestamp only when we decide to write\n                current_time = time.time()\n                for workspace_data in session_data.values():\n                    workspace_data['last_saved'] = current_time\n                \n                # Only write session file if data changed\n                with open(self.session_file, 'w', encoding='utf-8') as f:\n                    json.dump(session_data, f, indent=2)\n                self._last_session_hash = session_hash\n                files_written += 1\n            \n            return True\n            \n        except Exception:\n            return False\n    \n    def load_sessions(self) -> Dict[int, WorkspaceData]:\n        \"\"\"Load workspace sessions from file\"\"\"\n        if not self.session_file.exists():\n            return self._create_default_workspaces()\n        \n        try:\n            with open(self.session_file, 'r', encoding='utf-8') as f:\n                session_data = json.load(f)\n            \n            workspaces = {}\n            for workspace_id_str, data in session_data.items():\n                workspace_id = int(workspace_id_str)\n                \n                # Load tabs\n                tabs = [TabData(**tab_data) for tab_data in data.get('tabs', [])]\n                if not tabs:  # Ensure at least one tab\n                    tabs = [TabData(url=CHATGPT_URL)]\n                \n                # Load notepad content from separate file\n                notepad_file = get_workspace_notepad_file(workspace_id)\n                notepad_content = \"\"\n                if notepad_file.exists():\n                    try:\n                        notepad_content = notepad_file.read_text(encoding='utf-8')\n                    except Exception:\n                        pass  # Use empty notepad content\n                \n                workspaces[workspace_id] = WorkspaceData(\n                    name=data.get('name', DEFAULT_WORKSPACE_NAMES[workspace_id]),\n                    tabs=tabs,\n                    active_tab=max(0, min(data.get('active_tab', 0), len(tabs) - 1)),\n                    notepad_content=notepad_content,\n                    notepad_visible=data.get('notepad_visible', False),\n                    color=data.get('color')\n                )\n            \n            # Ensure we have all 4 workspaces\n            for i in range(4):\n                if i not in workspaces:\n                    workspaces[i] = WorkspaceData(\n                        name=DEFAULT_WORKSPACE_NAMES[i],\n                        tabs=[TabData(url=CHATGPT_URL)],\n                        active_tab=0,\n                        notepad_content=\"\",\n                        notepad_visible=False,\n                        color=None\n                    )\n            \n            return workspaces\n            \n        except Exception:\n            return self._create_default_workspaces()\n    \n    def _create_default_workspaces(self) -> Dict[int, WorkspaceData]:\n        \"\"\"Create default workspace configuration\"\"\"\n        return {\n            i: WorkspaceData(\n                name=DEFAULT_WORKSPACE_NAMES[i],\n                tabs=[TabData(url=CHATGPT_URL)],\n                active_tab=0,\n                notepad_content=\"\",\n                notepad_visible=False,\n                color=None\n            )\n            for i in range(4)\n        }\n    \n    def backup_sessions(self) -> bool:\n        \"\"\"Create a backup of current sessions\"\"\"\n        if not self.session_file.exists():\n            return False\n            \n        try:\n            import shutil\n            backup_file = self.session_file.with_suffix('.backup.json')\n            shutil.copy2(self.session_file, backup_file)\n            return True\n        except Exception:\n            return False","size_bytes":6974},"src/ui/__init__.py":{"content":"# UI module","size_bytes":11},"src/ui/main_window.py":{"content":"\"\"\"\nMain application window with workspace management\n\"\"\"\n\nfrom typing import Dict, Optional\nfrom PyQt6.QtWidgets import (\n    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,\n    QFrame, QPushButton, QStackedWidget, QMenu,\n    QDialog, QLineEdit, QLabel, QDialogButtonBox,\n    QSplitter, QColorDialog\n)\nfrom PyQt6.QtCore import Qt, QTimer, pyqtSignal\nfrom PyQt6.QtGui import QIcon, QKeySequence, QShortcut, QFont\n\nfrom ..config import COLORS, NUM_WORKSPACES, AUTOSAVE_INTERVAL_MS\nfrom ..paths import get_assets_dir\nfrom ..storage.session_manager import SessionManager, WorkspaceData\nfrom ..web.workspace import WorkspaceWidget\nfrom .notepad import NotepadWidget\n# Notifications removed as requested\nfrom .memory_manager import MemoryManager\n# Removed animated widgets to eliminate workspace switching artifacts\n\n\nclass WorkspaceRenameDialog(QDialog):\n    \"\"\"Dialog for renaming workspaces\"\"\"\n    \n    def __init__(self, current_name: str, current_color: str = None, parent=None):\n        super().__init__(parent)\n        self.setWindowTitle(\"Customize Workspace\")\n        self.setModal(True)\n        self.selected_color = current_color\n        self.setup_ui(current_name)\n        self.setup_style()\n    \n    def setup_ui(self, current_name: str):\n        \"\"\"Setup dialog UI\"\"\"\n        layout = QVBoxLayout(self)\n        \n        # Name section\n        self.name_edit = QLineEdit(current_name)\n        self.name_edit.selectAll()\n        layout.addWidget(QLabel(\"Workspace Name:\"))\n        layout.addWidget(self.name_edit)\n        \n        # Color section\n        layout.addWidget(QLabel(\"Workspace Color:\"))\n        color_layout = QHBoxLayout()\n        \n        # Color preview button\n        self.color_button = QPushButton()\n        self.color_button.setMinimumSize(40, 30)\n        self.color_button.clicked.connect(self.choose_color)\n        self.update_color_button()\n        color_layout.addWidget(self.color_button)\n        \n        # Reset color button\n        reset_button = QPushButton(\"Reset to Default\")\n        reset_button.clicked.connect(self.reset_color)\n        color_layout.addWidget(reset_button)\n        \n        layout.addLayout(color_layout)\n        \n        # Buttons\n        buttons = QDialogButtonBox(\n            QDialogButtonBox.StandardButton.Ok | \n            QDialogButtonBox.StandardButton.Cancel\n        )\n        buttons.accepted.connect(self.accept)\n        buttons.rejected.connect(self.reject)\n        layout.addWidget(buttons)\n    \n    def choose_color(self):\n        \"\"\"Open color picker dialog\"\"\"\n        from PyQt6.QtGui import QColor\n        current_color = QColor(self.selected_color) if self.selected_color else QColor(COLORS['accent'])\n        color = QColorDialog.getColor(current_color, self, \"Choose Workspace Color\")\n        if color.isValid():\n            self.selected_color = color.name()\n            self.update_color_button()\n    \n    def reset_color(self):\n        \"\"\"Reset color to default\"\"\"\n        self.selected_color = None\n        self.update_color_button()\n    \n    def update_color_button(self):\n        \"\"\"Update the color preview button\"\"\"\n        if self.selected_color:\n            self.color_button.setStyleSheet(f\"\"\"\n                QPushButton {{\n                    background-color: {self.selected_color};\n                    border: 2px solid {COLORS['text']};\n                    border-radius: 4px;\n                }}\n            \"\"\")\n            self.color_button.setText(\"\")\n        else:\n            self.color_button.setStyleSheet(f\"\"\"\n                QPushButton {{\n                    background-color: {COLORS['accent']};\n                    border: 2px solid {COLORS['text']};\n                    border-radius: 4px;\n                    color: {COLORS['text']};\n                }}\n            \"\"\")\n            self.color_button.setText(\"Default\")\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QDialog {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n            }}\n            QLineEdit {{\n                background-color: {COLORS['primary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 3px;\n                padding: 5px;\n                color: {COLORS['text']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['accent']};\n                border: none;\n                border-radius: 3px;\n                padding: 5px 10px;\n                color: {COLORS['text']};\n            }}\n            QPushButton:hover {{\n                background-color: #4c4c4c;\n            }}\n            QLabel {{\n                color: {COLORS['text']};\n            }}\n        \"\"\")\n    \n    def get_name(self) -> str:\n        \"\"\"Get the entered workspace name\"\"\"\n        return self.name_edit.text().strip()\n\n\nclass MainWindow(QMainWindow):\n    \"\"\"Main application window\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self.session_manager = SessionManager()\n        self.workspaces: Dict[int, WorkspaceWidget] = {}\n        self.notepads: Dict[int, NotepadWidget] = {}\n        self.current_workspace = 0\n        \n        # Initialize workspace names early to avoid initialization errors\n        self.workspace_names = [f\"Workspace {i+1}\" for i in range(NUM_WORKSPACES)]\n        \n        # Change tracking flags\n        self.session_dirty = False\n        self.notepad_dirty = False\n        \n# Notification system removed as requested\n        \n        # Memory manager for intelligent workspace compression\n        self.memory_manager = MemoryManager(self)\n        self.memory_manager.workspace_needs_loading.connect(self._handle_workspace_loading)\n        self.memory_manager.compress_workspace_signal.connect(self._compress_workspace)\n        \n        # Animations removed to eliminate artifacts\n        \n        # Auto-save timer\n        self.autosave_timer = QTimer()\n        self.autosave_timer.timeout.connect(self.save_sessions)\n        self.autosave_timer.start(AUTOSAVE_INTERVAL_MS)\n        \n        self.setup_ui()\n        self.setup_shortcuts()\n        self.load_sessions()\n        self.setup_style()\n        \n        # Set initial window title with current workspace\n        self.update_window_title()\n    \n    def setup_ui(self):\n        \"\"\"Setup the main UI\"\"\"\n        self.setWindowTitle(\"ChatGPT Browser\")\n        self.setGeometry(100, 100, 1200, 800)\n        \n        # Set window icon\n        assets_dir = get_assets_dir()\n        logo_path = assets_dir / \"logo.png\"\n        if logo_path.exists():\n            self.setWindowIcon(QIcon(str(logo_path)))\n        \n        # Central widget\n        central_widget = QWidget()\n        self.setCentralWidget(central_widget)\n        layout = QVBoxLayout(central_widget)\n        layout.setContentsMargins(0, 0, 0, 0)\n        \n# Status indicator removed as requested\n        \n        # Create container for main content with workspace pill overlay\n        content_container = QWidget()\n        content_layout = QVBoxLayout(content_container)\n        content_layout.setContentsMargins(0, 0, 0, 0)\n        \n        # Main content area with workspaces (instant switching)\n        self.workspace_stack = QStackedWidget()\n        content_layout.addWidget(self.workspace_stack)\n        \n        # Workspace pill now handled by individual tab widgets\n        \n        layout.addWidget(content_container)\n        \n    \n    def get_current_workspace_name(self) -> str:\n        \"\"\"Get the name of the current workspace\"\"\"\n        return self.workspace_names[self.current_workspace]\n    \n    def rename_current_workspace(self):\n        \"\"\"Show customize dialog for current workspace\"\"\"\n        current_name = self.get_current_workspace_name()\n        \n        # Get current workspace data to retrieve current color\n        workspace_widget = self.workspaces.get(self.current_workspace)\n        current_color = workspace_widget.workspace_data.color if workspace_widget else None\n        \n        dialog = WorkspaceRenameDialog(current_name, current_color, self)\n        if dialog.exec() == QDialog.DialogCode.Accepted:\n            new_name = dialog.name_edit.text().strip()\n            new_color = dialog.selected_color\n            \n            name_changed = new_name and new_name != current_name\n            color_changed = new_color != current_color\n            \n            if name_changed or color_changed:\n                if name_changed:\n                    # Update workspace name\n                    self.workspace_names[self.current_workspace] = new_name\n                    self.update_window_title()\n                \n                # Update current workspace data and save\n                if workspace_widget:\n                    if name_changed:\n                        workspace_widget.workspace_data.name = new_name\n                    if color_changed:\n                        workspace_widget.workspace_data.color = new_color\n                        # Apply the new color theme immediately\n                        workspace_widget.tab_widget.update_workspace_name(\n                            workspace_widget.workspace_data.name, \n                            workspace_widget.workspace_data\n                        )\n                    \n                    # Mark session as dirty and save all workspace sessions\n                    self.session_dirty = True\n                    self.save_sessions()\n    \n    def update_window_title(self):\n        \"\"\"Update window title with current workspace name\"\"\"\n        workspace_name = self.get_current_workspace_name()\n        self.setWindowTitle(f\"ChatGPT Browser - {workspace_name}\")\n        \n        # Update corner widget pill in current workspace\n        workspace_widget = self.workspaces.get(self.current_workspace)\n        if workspace_widget and hasattr(workspace_widget, 'tab_widget'):\n            workspace_widget.tab_widget.update_workspace_name(workspace_name, workspace_widget.workspace_data)\n    \n    def resizeEvent(self, event):\n        \"\"\"Handle window resize (workspace pill now handled by tab widgets)\"\"\"\n        super().resizeEvent(event)\n    \n    def setup_shortcuts(self):\n        \"\"\"Setup keyboard shortcuts\"\"\"\n        # Tab management\n        QShortcut(QKeySequence(\"Ctrl+T\"), self, self.new_tab)\n        QShortcut(QKeySequence(\"Ctrl+W\"), self, self.close_current_tab)\n        QShortcut(QKeySequence(\"Ctrl+Shift+T\"), self, self.restore_last_closed_tab)\n        QShortcut(QKeySequence(\"Ctrl+Tab\"), self, self.next_tab)\n        QShortcut(QKeySequence(\"Ctrl+Shift+Tab\"), self, self.previous_tab)\n        \n        # Navigation\n        QShortcut(QKeySequence(\"Ctrl+R\"), self, self.reload_current_tab)\n        QShortcut(QKeySequence(\"Alt+Left\"), self, self.navigate_back)\n        QShortcut(QKeySequence(\"Alt+Right\"), self, self.navigate_forward)\n        \n        # Workspace and features\n        QShortcut(QKeySequence(\"Ctrl+Shift+K\"), self, self.toggle_current_notepad)\n        QShortcut(QKeySequence(\"Ctrl+Shift+R\"), self, self.rename_current_workspace)\n        QShortcut(QKeySequence(\"Ctrl+Shift+1\"), self, lambda: self.switch_workspace(0))\n        QShortcut(QKeySequence(\"Ctrl+Shift+2\"), self, lambda: self.switch_workspace(1))\n        QShortcut(QKeySequence(\"Ctrl+Shift+3\"), self, lambda: self.switch_workspace(2))\n        QShortcut(QKeySequence(\"Ctrl+Shift+4\"), self, lambda: self.switch_workspace(3))\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QMainWindow {{\n                background-color: {COLORS['primary_bg']};\n                color: {COLORS['text']};\n            }}\n            QFrame {{\n                background-color: {COLORS['secondary_bg']};\n                border-bottom: 1px solid {COLORS['accent']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 5px;\n                padding: 8px 12px;\n                font-weight: bold;\n            }}\n            QPushButton:checked {{\n                background-color: {COLORS['accent']};\n                border-color: #5c5c5c;\n            }}\n            QPushButton:hover {{\n                background-color: {COLORS['accent']};\n            }}\n            QStackedWidget {{\n                background-color: {COLORS['primary_bg']};\n            }}\n        \"\"\")\n    \n    def load_sessions(self):\n        \"\"\"Load workspace sessions\"\"\"\n        workspace_data = self.session_manager.load_sessions()\n        \n        for workspace_id, data in workspace_data.items():\n            # Create workspace widget\n            workspace_widget = WorkspaceWidget(workspace_id, data, self.toggle_current_notepad, self)\n            workspace_widget.session_changed.connect(self._mark_session_dirty)\n            \n            self.workspaces[workspace_id] = workspace_widget\n            \n            # Create notepad widget\n            notepad_widget = NotepadWidget(self)\n            notepad_widget.set_content(data.notepad_content)\n            notepad_widget.content_changed.connect(self._mark_notepad_dirty)\n            notepad_widget.close_requested.connect(lambda: self.toggle_current_notepad(False))\n            self.notepads[workspace_id] = notepad_widget\n            \n            # Create combined widget with splitter\n            from PyQt6.QtWidgets import QSplitter\n            combined_widget = QWidget()\n            layout = QVBoxLayout(combined_widget)\n            layout.setContentsMargins(0, 0, 0, 0)\n            \n            splitter = QSplitter(Qt.Orientation.Vertical)\n            splitter.setObjectName(\"main-splitter\")\n            splitter.addWidget(workspace_widget)\n            splitter.addWidget(notepad_widget)\n            # Use proportional sizing based on initial splitter height\n            initial_height = 600  # Default height during setup\n            main_height = int(initial_height * 0.75)\n            notepad_height = int(initial_height * 0.25)\n            \n            splitter.setSizes([initial_height, 0])  # Hide notepad initially\n            \n            if data.notepad_visible:\n                splitter.setSizes([main_height, notepad_height])\n                notepad_widget.show()\n            else:\n                notepad_widget.hide()\n            \n            layout.addWidget(splitter)\n            self.workspace_stack.addWidget(combined_widget)\n            \n            # Update workspace name\n            if workspace_id < len(self.workspace_names):\n                self.workspace_names[workspace_id] = data.name\n        \n# Notifications removed - workspaces loaded silently\n    \n    def _mark_session_dirty(self):\n        \"\"\"Mark session data as dirty (needs saving)\"\"\"\n        self.session_dirty = True\n    \n    def _mark_notepad_dirty(self):\n        \"\"\"Mark notepad data as dirty (needs saving)\"\"\"\n        self.notepad_dirty = True\n    \n    \n    def save_sessions(self):\n        \"\"\"Save current workspace sessions (optimized with change detection)\"\"\"\n        # Check if we have any changes to save\n        if not (self.session_dirty or self.notepad_dirty):\n            # Timer-based save with no changes - skip to reduce I/O\n            return\n        \n        workspace_data = {}\n        for workspace_id in range(NUM_WORKSPACES):\n            if workspace_id in self.workspaces and workspace_id in self.notepads:\n                session_data = self.workspaces[workspace_id].get_session_data()\n                # Update notepad content\n                session_data.notepad_content = self.notepads[workspace_id].get_content()\n                session_data.notepad_visible = self.notepads[workspace_id].isVisible()\n                workspace_data[workspace_id] = session_data\n        \n        # Save to session manager\n        if self.session_manager.save_sessions(workspace_data):\n            # Clear change flags only after successful save\n            self.session_dirty = False\n            self.notepad_dirty = False\n            \n            # Clear notepad change flags\n            for notepad in self.notepads.values():\n                notepad.clear_changes_flag()\n    \n    def switch_workspace(self, workspace_id: int):\n        \"\"\"Switch to specified workspace\"\"\"\n        if workspace_id == self.current_workspace or workspace_id >= NUM_WORKSPACES:\n            return\n        \n        # Save current workspace session\n        self.save_sessions()\n        \n        # Track workspace usage for memory management\n        self.memory_manager.mark_workspace_used(workspace_id)\n        \n        # Also mark current tab as used\n        workspace_widget = self.workspaces.get(workspace_id)\n        if workspace_widget and hasattr(workspace_widget, 'tab_widget'):\n            current_tab_index = workspace_widget.tab_widget.currentIndex()\n            if current_tab_index >= 0:\n                self.memory_manager.mark_tab_used(workspace_id, current_tab_index)\n        \n        # Check if workspace needs to be restored from compression\n        if self.memory_manager.is_workspace_compressed(workspace_id):\n            workspace_widget = self.workspaces.get(workspace_id)\n            if workspace_widget:\n                self.memory_manager.restore_workspace(workspace_id, workspace_widget)\n        \n        # Switch workspace\n        self.current_workspace = workspace_id\n        self.workspace_stack.setCurrentIndex(workspace_id)\n        \n        # Update window title to show current workspace\n        self.update_window_title()\n    \n    def show_workspace_context_menu(self, workspace_id: int, pos):\n        \"\"\"Show context menu for workspace renaming - not used in minimal UI\"\"\"\n        # Context menu functionality removed in minimal design\n        pass\n    \n    def rename_workspace(self, workspace_id: int):\n        \"\"\"Rename a workspace\"\"\"\n        current_name = self.workspace_names[workspace_id]\n        dialog = WorkspaceRenameDialog(current_name, self)\n        \n        if dialog.exec() == QDialog.DialogCode.Accepted:\n            new_name = dialog.get_name()\n            if new_name:\n                self.workspace_names[workspace_id] = new_name\n                if workspace_id in self.workspaces:\n                    self.workspaces[workspace_id].workspace_data.name = new_name\n                # Update window title if this is the current workspace\n                if workspace_id == self.current_workspace:\n                    self.setWindowTitle(f\"ChatGPT Browser - {new_name}\")\n                self._mark_session_dirty()\n                self.save_sessions()\n    \n    def get_current_workspace(self) -> Optional[WorkspaceWidget]:\n        \"\"\"Get the currently active workspace widget\"\"\"\n        return self.workspaces.get(self.current_workspace)\n    \n    def get_current_notepad(self) -> Optional[NotepadWidget]:\n        \"\"\"Get the currently active notepad widget\"\"\"\n        return self.notepads.get(self.current_workspace)\n    \n    def _handle_workspace_loading(self, workspace_id: int):\n        \"\"\"Handle workspace loading when switching to a compressed workspace\"\"\"\n        workspace_widget = self.workspaces.get(workspace_id)\n        if workspace_widget and self.memory_manager.is_workspace_compressed(workspace_id):\n            self.memory_manager.restore_workspace(workspace_id, workspace_widget)\n    \n    def _compress_workspace(self, workspace_id: int):\n        \"\"\"Compress an unused workspace to save memory\"\"\"\n        if workspace_id == self.current_workspace:\n            # Don't compress the currently active workspace\n            return\n            \n        workspace_widget = self.workspaces.get(workspace_id)\n        if workspace_widget:\n            self.memory_manager.compress_workspace(workspace_id, workspace_widget)\n    \n    # Tab management methods\n    def new_tab(self):\n        \"\"\"Create new tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.new_tab()\n    \n    def close_current_tab(self):\n        \"\"\"Close current tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            current_index = workspace.tab_widget.currentIndex()\n            workspace.close_tab(current_index)\n    \n    def restore_last_closed_tab(self):\n        \"\"\"Restore last closed tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.restore_last_closed_tab()\n    \n    def next_tab(self):\n        \"\"\"Switch to next tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            count = workspace.tab_widget.count()\n            current = workspace.tab_widget.currentIndex()\n            next_index = (current + 1) % count\n            workspace.tab_widget.setCurrentIndex(next_index)\n    \n    def previous_tab(self):\n        \"\"\"Switch to previous tab in current workspace\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            count = workspace.tab_widget.count()\n            current = workspace.tab_widget.currentIndex()\n            prev_index = (current - 1) % count\n            workspace.tab_widget.setCurrentIndex(prev_index)\n    \n    # Navigation methods\n    def reload_current_tab(self):\n        \"\"\"Reload current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.reload_current_tab()\n    \n    def navigate_back(self):\n        \"\"\"Navigate back in current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.navigate_back()\n    \n    def navigate_forward(self):\n        \"\"\"Navigate forward in current tab\"\"\"\n        workspace = self.get_current_workspace()\n        if workspace:\n            workspace.navigate_forward()\n    \n    def toggle_current_notepad(self, show: Optional[bool] = None):\n        \"\"\"Toggle notepad for current workspace instantly (animations removed)\"\"\"\n        notepad = self.get_current_notepad()\n        if notepad:\n            # Get the splitter from the current workspace\n            current_widget = self.workspace_stack.currentWidget()\n            if current_widget:\n                splitter = current_widget.findChild(QSplitter, \"main-splitter\")\n                if splitter:\n                    if show is None:\n                        show = not notepad.isVisible()\n                    \n                    # Calculate proportional sizes based on splitter height\n                    total_height = splitter.height() if splitter.height() > 0 else 800\n                    main_height = int(total_height * 0.75)  # 75% for main area\n                    notepad_height = int(total_height * 0.25)  # 25% for notepad\n                    \n                    if show:\n                        notepad.show()\n                        # Instantly set sizes for show - no animation\n                        splitter.setSizes([main_height, notepad_height])\n                    else:\n                        # Instantly hide notepad - no animation\n                        splitter.setSizes([total_height, 0])\n                        notepad.hide()\n                    \n                    self._mark_session_dirty()\n                    self.save_sessions()\n    \n    def closeEvent(self, a0):\n        \"\"\"Handle application close event\"\"\"\n        # Force immediate save of any pending notepad changes\n        self._force_save_pending_changes()\n        \n        # Save sessions before closing\n        self.save_sessions()\n        \n        # Clean up resources\n        for workspace in self.workspaces.values():\n            workspace.cleanup()\n        \n        if a0:\n            a0.accept()\n    \n    def _force_save_pending_changes(self):\n        \"\"\"Force immediate save of any pending notepad changes that haven't triggered dirty flags yet\"\"\"\n        # Check each notepad for unsaved changes and stop any pending debounce timers\n        for notepad in self.notepads.values():\n            # Stop any pending debounce timers to prevent them from firing after we've saved\n            if hasattr(notepad, '_save_timer') and notepad._save_timer.isActive():\n                notepad._save_timer.stop()\n            \n            # If notepad has changes that haven't been marked dirty yet, mark them now\n            if notepad.has_changes():\n                self.notepad_dirty = True\n                # Force the content_changed signal to fire immediately\n                notepad._emit_content_changed()","size_bytes":24526},"src/ui/notepad.py":{"content":"\"\"\"\nNotepad widget with Markdown support\n\"\"\"\n\nfrom PyQt6.QtWidgets import (\n    QWidget, QVBoxLayout, QHBoxLayout, QLabel, \n    QPushButton, QTextEdit, QFrame\n)\nfrom PyQt6.QtCore import Qt, pyqtSignal, QTimer\nfrom PyQt6.QtGui import QFont\n\nfrom ..config import COLORS, NOTEPAD_SAVE_DEBOUNCE_MS\n\n\nclass NotepadWidget(QWidget):\n    \"\"\"Notepad widget with Markdown support\"\"\"\n    \n    content_changed = pyqtSignal()\n    close_requested = pyqtSignal()\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setup_ui()\n        self.setup_style()\n        self._content_changed = False\n        \n        # Debounce timer for efficient saving\n        self._save_timer = QTimer()\n        self._save_timer.setSingleShot(True)\n        self._save_timer.timeout.connect(self._emit_content_changed)\n        self._debounce_delay = NOTEPAD_SAVE_DEBOUNCE_MS\n    \n    def setup_ui(self):\n        \"\"\"Setup the notepad UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(10, 10, 10, 10)\n        \n        # Header\n        header = QHBoxLayout()\n        self.title_label = QLabel(\"Notepad\")\n        self.title_label.setFont(QFont(\"Arial\", 12, QFont.Weight.Bold))\n        header.addWidget(self.title_label)\n        header.addStretch()\n        \n        # Close button\n        self.close_btn = QPushButton(\"×\")\n        self.close_btn.setFixedSize(20, 20)\n        self.close_btn.clicked.connect(self.close_requested.emit)\n        header.addWidget(self.close_btn)\n        \n        layout.addLayout(header)\n        \n        # Text editor\n        self.text_edit = QTextEdit()\n        self.text_edit.setFont(QFont(\"Consolas\", 10))\n        self.text_edit.textChanged.connect(self._on_text_changed)\n        self.text_edit.setPlaceholderText(\"Write your notes here... Markdown is supported!\")\n        layout.addWidget(self.text_edit)\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 5px;\n            }}\n            QTextEdit {{\n                background-color: {COLORS['primary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 3px;\n                padding: 8px;\n                font-family: 'Consolas', monospace;\n                color: {COLORS['text']};\n            }}\n            QPushButton {{\n                background-color: {COLORS['accent']};\n                border: none;\n                border-radius: 10px;\n                font-weight: bold;\n                color: {COLORS['text']};\n            }}\n            QPushButton:hover {{\n                background-color: #4c4c4c;\n            }}\n            QLabel {{\n                border: none;\n                color: {COLORS['text']};\n            }}\n        \"\"\")\n    \n    def _on_text_changed(self):\n        \"\"\"Mark content as changed when text is modified\"\"\"\n        self._content_changed = True\n        # Debounce the save signal to avoid excessive I/O\n        self._save_timer.stop()\n        self._save_timer.start(self._debounce_delay)\n    \n    def _emit_content_changed(self):\n        \"\"\"Emit content changed signal after debounce delay\"\"\"\n        if self._content_changed:\n            self.content_changed.emit()\n    \n    def set_content(self, content: str):\n        \"\"\"Set notepad content\"\"\"\n        self.text_edit.setPlainText(content)\n        self._content_changed = False\n    \n    def get_content(self) -> str:\n        \"\"\"Get notepad content\"\"\"\n        return self.text_edit.toPlainText()\n    \n    def has_changes(self) -> bool:\n        \"\"\"Check if content has been modified\"\"\"\n        return self._content_changed\n    \n    def clear_changes_flag(self):\n        \"\"\"Clear the changes flag (called after saving)\"\"\"\n        self._content_changed = False","size_bytes":3948},"src/web/__init__.py":{"content":"\"\"\"Web module for workspace and browser functionality\"\"\"\n\nfrom .workspace import WorkspaceWidget\n\n__all__ = ['WorkspaceWidget']","size_bytes":127},"src/web/url_filter.py":{"content":"\"\"\"\nURL filtering to restrict navigation to ChatGPT domains only\n\"\"\"\n\nfrom PyQt6.QtCore import QObject, QUrl\nfrom PyQt6.QtWebEngineCore import QWebEngineUrlRequestInterceptor, QWebEngineUrlRequestInfo\n\n\nclass ChatGPTUrlFilter(QWebEngineUrlRequestInterceptor):\n    \"\"\"URL filter to restrict navigation to ChatGPT domains only\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # Allowed domains for ChatGPT functionality (minimal and specific)\n        self.allowed_domains = {\n            'chatgpt.com',\n            # Complete OAuth/Auth domains for login flows\n            'auth0.openai.com',\n            'auth.openai.com', \n            'login.openai.com',\n            'openai.auth0.com',\n            # Essential OpenAI API and CDN domains\n            'cdn.openai.com', \n            'static.openai.com',\n            'api.openai.com',\n            'files.oaiusercontent.com',\n            # CRITICAL: Main ChatGPT CDN for CSS/JS resources\n            'cdn.oaistatic.com',\n            'oaistatic.com',\n            # Specific CDN subdomains that ChatGPT actually uses\n            'cdnjs.cloudflare.com',\n            'chat.openai.com.cdn.cloudflare.net',\n            # Required for OAuth and essential functionality\n            'openaiapi-site.azureedge.net',\n            'openaicomproductionae4b.blob.core.windows.net',\n            # Additional voice features\n            'chatgpt.livekit.cloud'\n        }\n        \n        # Allowed URL patterns for specific resources\n        self.allowed_patterns = [\n            'data:',  # Data URLs for images, etc.\n            'blob:',  # Blob URLs for file handling\n            'about:blank',  # Blank pages\n        ]\n    \n    def interceptRequest(self, info: QWebEngineUrlRequestInfo):\n        \"\"\"Intercept and filter URL requests\"\"\"\n        url = info.requestUrl()\n        url_string = url.toString()\n        \n        # Allow specific URL patterns\n        for pattern in self.allowed_patterns:\n            if url_string.startswith(pattern):\n                return\n        \n        # Check domain\n        host = url.host().lower()\n        \n        # Allow main domain and subdomains\n        allowed = False\n        for domain in self.allowed_domains:\n            if host == domain or host.endswith('.' + domain):\n                allowed = True\n                break\n        \n        # Block if not allowed\n        if not allowed:\n            info.block(True)\n            return\n        \n        # Allow the request explicitly\n        info.block(False)","size_bytes":2531},"src/web/workspace.py":{"content":"\"\"\"\nWeb workspace management with isolated QtWebEngine profiles\n\"\"\"\n\nimport os\nfrom typing import List, Optional, Callable\nfrom PyQt6.QtCore import Qt, QUrl, pyqtSignal\nfrom PyQt6.QtWidgets import QWidget, QVBoxLayout, QTabWidget, QHBoxLayout, QLabel, QPushButton, QFrame\nfrom PyQt6.QtGui import QIcon, QFont\nfrom PyQt6.QtWebEngineWidgets import QWebEngineView\nfrom PyQt6.QtWebEngineCore import QWebEngineProfile, QWebEngineSettings, QWebEnginePage, QWebEngineScript\n\nfrom ..config import CHATGPT_URL\nfrom ..paths import get_workspace_profile_dir\nfrom ..storage.session_manager import TabData, WorkspaceData\nfrom .oauth_handler import OAuthHandler\nfrom .security_interceptor import SecurityInterceptor\n\n\nclass SecurePage(QWebEnginePage):\n    \"\"\"Custom QWebEnginePage that properly handles navigation with security and OAuth checks\"\"\"\n    \n# OAuth notifications removed\n    \n    def __init__(self, profile: QWebEngineProfile, parent=None):\n        super().__init__(profile, parent)\n        \n        # Setup security components\n        self.oauth_handler = OAuthHandler(self)\n        self.security_interceptor = SecurityInterceptor(self)\n        \n        # Flag to suppress security dialogs (for popups)\n        self.suppress_security_dialogs = False\n        \n        # Inject CSS to hide jarring skip-to-content popups\n        self.inject_skip_content_blocker()\n        \n# OAuth notification signals removed\n    \n    def inject_skip_content_blocker(self):\n        \"\"\"Inject CSS to hide skip-to-content popups that appear during navigation\"\"\"\n        css_code = \"\"\"\n        /* Hide common skip-to-content elements that cause jarring popups */\n        a[href^=\"#skip-to-content\"],\n        [data-testid=\"skip-to-content\"],\n        #skip-to-content,\n        .skip-to-content,\n        a[href=\"#main\"],\n        a[href=\"#content\"],\n        .sr-only:focus,\n        .visually-hidden:focus {\n            display: none !important;\n            visibility: hidden !important;\n            opacity: 0 !important;\n            position: absolute !important;\n            left: -9999px !important;\n        }\n        \n        /* Also hide any accessibility skip links that might pop up */\n        a.skip-link,\n        a.skip-nav,\n        .skip-navigation {\n            display: none !important;\n        }\n        \"\"\"\n        \n        script = QWebEngineScript()\n        script.setSourceCode(f\"\"\"\n            (function() {{\n                var style = document.createElement('style');\n                style.textContent = `{css_code}`;\n                if (document.head) {{\n                    document.head.appendChild(style);\n                }} else {{\n                    document.addEventListener('DOMContentLoaded', function() {{\n                        document.head.appendChild(style);\n                    }});\n                }}\n            }})();\n        \"\"\")\n        script.setInjectionPoint(QWebEngineScript.InjectionPoint.DocumentReady)\n        script.setWorldId(QWebEngineScript.ScriptWorldId.ApplicationWorld)\n        script.setRunsOnSubFrames(True)\n        \n        # Add script to profile so it applies to all pages\n        profile = self.profile()\n        if profile:\n            profile.scripts().insert(script)\n    \n    def acceptNavigationRequest(self, url: QUrl, nav_type, is_main_frame: bool) -> bool:\n        \"\"\"Override navigation request handling with security and OAuth checks\"\"\"\n        url_str = url.toString()\n        \n        # Check security (schemes and domains)\n        should_block, reason = self.security_interceptor.should_block_url(url_str)\n        \n        if should_block:\n            # If it's a scheme issue or dangerous scheme, block silently\n            if \"not allowed\" in reason.lower() or any(term in reason.lower() for term in ['scheme', 'internal pages']):\n                return False\n            \n            # If it's a domain issue and we have a main window, show warning dialog (unless suppressed)\n            if \"not in allowlist\" in reason.lower() and is_main_frame and not self.suppress_security_dialogs:\n                domain = self.security_interceptor.get_domain_from_url(url_str)\n                if domain:\n                    # Show warning dialog\n                    from ..ui.security_dialog import DomainWarningDialog\n                    dialog = DomainWarningDialog(url_str, domain, self.parent())\n                    \n                    if dialog.exec() == dialog.Accepted:\n                        choice = dialog.get_choice()\n                        if choice == dialog.ALLOW_ONCE:\n                            # Allow for this session\n                            self.security_interceptor.allow_domain_once(domain)\n                            return True\n                        elif choice == dialog.ADD_TO_ALLOWLIST:\n                            # Add to permanent allowlist\n                            self.security_interceptor.add_domain_to_allowlist(domain)\n                            return True\n                    \n                    # User cancelled or dialog failed\n                    return False\n            else:\n                # Block other types silently\n                return False\n        \n        # Check for OAuth redirects on main frame navigation\n        if is_main_frame and self.oauth_handler.handle_navigation_request(url_str):\n            # OAuth handler redirected to system browser\n            return False\n        \n        # Allow all other navigation\n        return True\n    \n# OAuth redirect notifications removed\n    \n    def createWindow(self, window_type):\n        \"\"\"\n        Override popup window creation to ensure all popups use SecurePage with same security checks.\n        Critical security method - ensures OAuth popups can't bypass security.\n        \"\"\"\n        from PyQt6.QtWebEngineCore import QWebEnginePage\n        \n        # Get the URL that will be loaded in the popup (if available)\n        # Note: Qt doesn't always provide the target URL at createWindow time\n        \n        # Create a new secure page with same profile for popup\n        popup_page = SecurePage(self.profile(), self.parent())\n        \n        # Suppress security dialogs for popups (block silently)\n        popup_page.suppress_security_dialogs = True\n        \n# Popup OAuth notifications removed\n        \n        # Override the popup's acceptNavigationRequest to handle OAuth immediately\n        original_accept = popup_page.acceptNavigationRequest\n        \n        def popup_navigation_handler(url, nav_type, is_main_frame):\n            \"\"\"Enhanced navigation handler for popup windows\"\"\"\n            url_str = url.toString()\n            \n            # Check security first\n            should_block, reason = self.security_interceptor.should_block_url(url_str)\n            if should_block:\n                # For popups, be more restrictive - don't show dialogs, just block\n                popup_page.deleteLater()\n                return False\n            \n            # For popups, check OAuth redirects immediately on ANY navigation\n            # (not just main frame like in regular tabs)\n            if self.oauth_handler.handle_navigation_request(url_str):\n                # OAuth handler redirected to system browser\n                # Close the popup since OAuth is handled externally\n                popup_page.deleteLater()\n                return False\n            \n            # Use original security checks for non-OAuth URLs\n            return original_accept(url, nav_type, is_main_frame)\n        \n        # Replace the navigation handler\n        popup_page.acceptNavigationRequest = popup_navigation_handler\n        \n        return popup_page\n\n\nclass ChatGPTWebView(QWebEngineView):\n    \"\"\"Custom web view for ChatGPT with isolated profile\"\"\"\n    \n# OAuth notifications removed\n    \n    def __init__(self, workspace_id: int, profile: QWebEngineProfile, parent=None):\n        super().__init__(parent)\n        \n        self.workspace_id = workspace_id\n        \n        # Use shared profile for this workspace\n        self.profile = profile\n        \n        # Create secure page with shared workspace profile\n        self.page_obj = SecurePage(self.profile, self)\n        self.setPage(self.page_obj)\n        \n        # Connect security signals from the secure page\n# OAuth notification connection removed\n        \n        # Configure for secure operation\n        self._setup_security_settings()\n        \n        # Load ChatGPT\n        self.load(QUrl(CHATGPT_URL))\n    \n    \n    def _setup_security_settings(self):\n        \"\"\"Setup security settings for the web engine\"\"\"\n        # Note: In production builds, we should NOT disable the sandbox\n        # This is only for development/CI environments\n        if os.environ.get(\"QTWEBENGINE_DISABLE_SANDBOX\") == \"1\":\n            # Only in headless CI environments\n            pass\n        \n        # Block permissions permanently as requested by user\n        settings = self.page().settings()\n        \n        # Disable plugins\n        settings.setAttribute(QWebEngineSettings.WebAttribute.PluginsEnabled, False)\n        \n        # Block mixed content\n        settings.setAttribute(QWebEngineSettings.WebAttribute.AllowRunningInsecureContent, False)\n        \n        # Connect permission requests to permanently deny them\n        profile = self.page().profile()\n        profile.downloadRequested.connect(self._block_download)\n        \n        # Override permission requests\n        self.page().featurePermissionRequested.connect(self._handle_permission_request)\n    \n    def _block_download(self, download):\n        \"\"\"Block all downloads permanently\"\"\"\n        download.cancel()\n    \n    def _handle_permission_request(self, url, feature):\n        \"\"\"Handle permission requests - deny all as requested\"\"\"\n        from PyQt6.QtWebEngineCore import QWebEnginePage\n        \n        # Always deny all permission requests\n        self.page().setFeaturePermission(url, feature, QWebEnginePage.PermissionPolicy.PermissionDeniedByUser)\n        \n        # Use default user agent for better compatibility\n    \n    def closeEvent(self, a0):\n        \"\"\"Clean up resources when closing\"\"\"\n        # Clean up page resources\n        if hasattr(self, 'page_obj') and self.page_obj:\n            self.page_obj.deleteLater()\n        \n        # Clear any cached URL history to free memory\n        history = self.history()\n        if history:\n            history.clear()\n        super().closeEvent(a0)\n\n\nclass WorkspaceTabWidget(QTabWidget):\n    \"\"\"Custom tab widget for individual workspace tabs\"\"\"\n    \n    tab_close_requested = pyqtSignal(int)\n    new_tab_requested = pyqtSignal()\n    \n    def __init__(self, workspace_name: str = \"\", notepad_toggle_callback: Optional[Callable] = None, parent=None):\n        super().__init__(parent)\n        self.setTabsClosable(False)  # Remove close buttons as requested\n        self.setMovable(True)\n        self.setDocumentMode(True)\n        \n        self.workspace_name = workspace_name\n        self.notepad_toggle_callback = notepad_toggle_callback\n        \n        self.setup_style()\n        self.setup_corner_widget()\n        \n        # Apply workspace theme if workspace data has custom colors\n        parent_workspace = self.parent()\n        while parent_workspace and parent_workspace.__class__.__name__ != 'WorkspaceWidget':\n            parent_workspace = parent_workspace.parent()\n        if parent_workspace and hasattr(parent_workspace, 'workspace_data'):\n            self.apply_workspace_theme(parent_workspace.workspace_data)\n    \n    def setup_style(self):\n        \"\"\"Apply dark theme styling to tabs\"\"\"\n        from ..config import COLORS\n        \n        # Clean modern tab styling (30% bigger, similar to reference image)\n        self.setStyleSheet(f\"\"\"\n            QTabWidget::pane {{\n                border: 1px solid {COLORS['accent']};\n                background-color: {COLORS['primary_bg']};\n                border-top: none;\n            }}\n            QTabBar::tab {{\n                background-color: {COLORS['secondary_bg']};\n                color: {COLORS['text']};\n                padding: 10px 20px;  /* 30% bigger padding */\n                margin-right: 1px;\n                border-top-left-radius: 8px;\n                border-top-right-radius: 8px;\n                min-width: 160px;  /* 30% bigger minimum width */\n                max-width: 240px;\n                font-family: \"Segoe UI\", Arial, sans-serif;\n                font-size: 11px;\n                font-weight: 500;\n                border: 1px solid transparent;\n                border-bottom: none;\n            }}\n            QTabBar::tab:selected {{\n                background-color: {COLORS['primary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-bottom: 1px solid {COLORS['primary_bg']};\n                color: {COLORS['text']};\n            }}\n            QTabBar::tab:hover:!selected {{\n                background-color: {COLORS['accent']};\n                border: 1px solid {COLORS['accent']};\n                border-bottom: none;\n            }}\n            QTabBar {{\n                qproperty-drawBase: 0;  /* Clean connection between tabs and pane */\n            }}\n        \"\"\")\n    \n    def setup_corner_widget(self):\n        \"\"\"Setup corner widget (workspace pill removed - name shown in window title instead)\"\"\"\n        # No corner widget needed - workspace name is shown in window title\n        pass\n    \n    def update_workspace_name(self, name: str, workspace_data=None):\n        \"\"\"Update the workspace name and apply theme\"\"\"\n        self.workspace_name = name\n        \n        # Apply workspace theme if data provided\n        if workspace_data:\n            self.apply_workspace_theme(workspace_data)\n    \n    def apply_workspace_theme(self, workspace_data: 'WorkspaceData'):\n        \"\"\"Apply custom workspace color theme to header and tabs\"\"\"\n        from ..config import COLORS\n        \n        # Use custom color if available, otherwise default\n        if workspace_data.color and workspace_data.color.startswith('#'):\n            accent_color = workspace_data.color\n            # Create a lighter version for hover\n            hover_color = self._lighten_color(accent_color, 0.1)\n        else:\n            accent_color = COLORS['accent']\n            hover_color = '#4c4c4c'\n        \n        # Create gradient colors for header and tabs\n        header_gradient_start = self._lighten_color(accent_color, 0.2)\n        header_gradient_end = self._darken_color(accent_color, 0.4)\n        tab_gradient_start = self._lighten_color(accent_color, 0.1)\n        tab_gradient_end = self._darken_color(accent_color, 0.2)\n        \n        # Apply theme with gradient header background and custom tab styling\n        self.setStyleSheet(f\"\"\"\n            QTabWidget::pane {{\n                border: 1px solid {accent_color};\n                background-color: {COLORS['primary_bg']};\n                border-top: none;\n            }}\n            QTabBar {{\n                background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n                    stop: 0 {header_gradient_start}, \n                    stop: 0.5 {accent_color},\n                    stop: 1 {header_gradient_end});\n                qproperty-drawBase: 0;\n                border-bottom: 2px solid {accent_color};\n                min-height: 35px;\n            }}\n            QTabBar::tab {{\n                background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n                    stop: 0 {tab_gradient_start}, \n                    stop: 1 {tab_gradient_end});\n                color: white;\n                padding: 12px 24px;\n                margin-right: 2px;\n                border-top-left-radius: 8px;\n                border-top-right-radius: 8px;\n                min-width: 160px;\n                max-width: 240px;\n                font-family: \"Segoe UI\", Arial, sans-serif;\n                font-size: 11px;\n                font-weight: 600;\n                border: 1px solid {accent_color};\n                border-bottom: none;\n                margin-bottom: 2px;\n            }}\n            QTabBar::tab:selected {{\n                background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n                    stop: 0 {self._lighten_color(accent_color, 0.3)}, \n                    stop: 1 {accent_color});\n                border: 2px solid {self._lighten_color(accent_color, 0.2)};\n                border-bottom: 2px solid {COLORS['primary_bg']};\n                color: white;\n                margin-bottom: 0px;\n            }}\n            QTabBar::tab:hover:!selected {{\n                background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,\n                    stop: 0 {self._lighten_color(accent_color, 0.15)}, \n                    stop: 1 {hover_color});\n                border: 1px solid {self._lighten_color(accent_color, 0.1)};\n                border-bottom: none;\n            }}\n        \"\"\")\n    \n    def _lighten_color(self, hex_color: str, amount: float) -> str:\n        \"\"\"Lighten a hex color by the specified amount (0.0 to 1.0)\"\"\"\n        try:\n            # Remove # if present\n            hex_color = hex_color.lstrip('#')\n            \n            # Convert to RGB\n            r = int(hex_color[0:2], 16)\n            g = int(hex_color[2:4], 16) \n            b = int(hex_color[4:6], 16)\n            \n            # Lighten each component\n            r = min(255, int(r + (255 - r) * amount))\n            g = min(255, int(g + (255 - g) * amount))\n            b = min(255, int(b + (255 - b) * amount))\n            \n            # Convert back to hex\n            return f\"#{r:02x}{g:02x}{b:02x}\"\n        except (ValueError, IndexError):\n            # Return default on error\n            return '#4c4c4c'\n    \n    def _darken_color(self, hex_color: str, amount: float) -> str:\n        \"\"\"Darken a hex color by the specified amount (0.0 to 1.0)\"\"\"\n        try:\n            # Remove # if present\n            hex_color = hex_color.lstrip('#')\n            \n            # Convert to RGB\n            r = int(hex_color[0:2], 16)\n            g = int(hex_color[2:4], 16) \n            b = int(hex_color[4:6], 16)\n            \n            # Darken each component\n            r = max(0, int(r * (1 - amount)))\n            g = max(0, int(g * (1 - amount)))\n            b = max(0, int(b * (1 - amount)))\n            \n            # Convert back to hex\n            return f\"#{r:02x}{g:02x}{b:02x}\"\n        except (ValueError, IndexError):\n            # Return default on error\n            return '#2a2a2a'\n\n\nclass WorkspaceWidget(QWidget):\n    \"\"\"Widget representing a single workspace with tabs\"\"\"\n    \n    session_changed = pyqtSignal()\n# Notifications removed\n    \n    def __init__(self, workspace_id: int, workspace_data: WorkspaceData, notepad_toggle_callback: Optional[Callable] = None, parent=None):\n        super().__init__(parent)\n        self.workspace_id = workspace_id\n        self.workspace_data = workspace_data\n        self.notepad_toggle_callback = notepad_toggle_callback\n        self.web_views: List[ChatGPTWebView] = []\n        self.closed_tabs: List[TabData] = []  # For tab restoration\n        self.max_closed_tabs = 10  # Limit memory usage from closed tabs\n        \n        # Create single shared profile for this workspace\n        self.workspace_profile = self._create_workspace_profile()\n        \n        self.setup_ui()\n        self.restore_session()\n    \n    def _create_workspace_profile(self) -> QWebEngineProfile:\n        \"\"\"Create a single shared profile for this workspace\"\"\"\n        profile_dir = get_workspace_profile_dir(self.workspace_id)\n        profile_name = f\"workspace_{self.workspace_id}\"\n        \n        # Create profile with persistent storage\n        profile = QWebEngineProfile(profile_name, self)\n        profile.setPersistentStoragePath(str(profile_dir))\n        profile.setCachePath(str(profile_dir / \"cache\"))\n        \n        # Enable persistent cookies and storage\n        profile.setPersistentCookiesPolicy(\n            QWebEngineProfile.PersistentCookiesPolicy.AllowPersistentCookies\n        )\n        \n        # OAuth compatibility - allow third-party cookies\n        try:\n            # Only available in Qt 6.6+\n            profile.setThirdPartyCookiePolicy(\n                QWebEngineProfile.ThirdPartyCookiePolicy.AllowAll\n            )\n        except AttributeError:\n            # Fallback for older Qt versions\n            pass\n        \n        # Configure profile settings for optimal ChatGPT experience\n        settings = profile.settings()\n        if settings:\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalStorageEnabled, True)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptEnabled, True)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.PluginsEnabled, False)  # Disable plugins for memory efficiency\n            settings.setAttribute(QWebEngineSettings.WebAttribute.AutoLoadImages, True)\n            # Security settings - restrict local content access\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalContentCanAccessRemoteUrls, False)\n            settings.setAttribute(QWebEngineSettings.WebAttribute.LocalContentCanAccessFileUrls, False)\n            \n            # Memory optimization settings\n            settings.setAttribute(QWebEngineSettings.WebAttribute.JavascriptCanOpenWindows, True)  # OAuth needs popups\n            settings.setAttribute(QWebEngineSettings.WebAttribute.WebGLEnabled, False)  # Disable WebGL for memory savings\n            settings.setAttribute(QWebEngineSettings.WebAttribute.Accelerated2dCanvasEnabled, False)  # Reduce GPU memory usage\n        \n        # Configure memory-efficient cache settings\n        # Set cache size limits to prevent excessive memory/disk usage\n        profile.setHttpCacheMaximumSize(50 * 1024 * 1024)  # 50MB cache limit\n        \n        # Set HTTP cache type for better memory management\n        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)\n        \n        # No URL filtering - allow all domains\n        \n        return profile\n    \n    def setup_ui(self):\n        \"\"\"Setup the workspace UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        \n        # Tab widget for web views with workspace info\n        workspace_name = self.workspace_data.name if self.workspace_data else f\"Workspace {self.workspace_id + 1}\"\n        self.tab_widget = WorkspaceTabWidget(workspace_name, self.notepad_toggle_callback)\n        self.tab_widget.tab_close_requested.connect(self.close_tab)\n        self.tab_widget.new_tab_requested.connect(self.new_tab)\n        self.tab_widget.currentChanged.connect(self._on_tab_changed)\n        \n        layout.addWidget(self.tab_widget)\n    \n    def restore_session(self):\n        \"\"\"Restore tabs from workspace data\"\"\"\n        for tab_data in self.workspace_data.tabs:\n            self.add_tab(tab_data.url)\n        \n        # Set active tab\n        if 0 <= self.workspace_data.active_tab < self.tab_widget.count():\n            self.tab_widget.setCurrentIndex(self.workspace_data.active_tab)\n    \n    def add_tab(self, url: str = CHATGPT_URL) -> int:\n        \"\"\"Add a new tab with ChatGPT\"\"\"\n        # Check if we have too many tabs (memory protection)\n        if len(self.web_views) >= 15:  # Limit tabs per workspace for memory efficiency\n            return self.tab_widget.currentIndex()  # Return current tab instead of failing\n            \n        web_view = ChatGPTWebView(self.workspace_id, self.workspace_profile)\n        web_view.load(QUrl(url))\n        \n        self.web_views.append(web_view)\n        tab_index = self.tab_widget.addTab(web_view, \"ChatGPT\")\n        \n        # Connect signals\n        web_view.titleChanged.connect(\n            lambda title, idx=tab_index: self._update_tab_title(idx, title)\n        )\n        # OAuth notification connection removed as requested\n        \n        self.session_changed.emit()\n        return tab_index\n    \n    def _update_tab_title(self, index: int, title: str):\n        \"\"\"Update tab title, truncating if too long\"\"\"\n        if index < self.tab_widget.count():\n            truncated_title = title[:30] + \"...\" if len(title) > 30 else title\n            self.tab_widget.setTabText(index, truncated_title)\n    \n    def close_tab(self, index: int):\n        \"\"\"Close a tab and save for restoration\"\"\"\n        if self.tab_widget.count() <= 1:\n            return  # Don't close the last tab\n        \n        web_view = self.tab_widget.widget(index)\n        if isinstance(web_view, ChatGPTWebView):\n            # Save tab data for restoration (with memory limit)\n            self.closed_tabs.append(TabData(\n                url=web_view.url().toString(),\n                title=self.tab_widget.tabText(index)\n            ))\n            \n            # Limit closed tabs to prevent memory leak\n            if len(self.closed_tabs) > self.max_closed_tabs:\n                self.closed_tabs.pop(0)  # Remove oldest closed tab\n            \n            # Remove from lists\n            if web_view in self.web_views:\n                self.web_views.remove(web_view)\n            \n            # Clean up web view resources\n            # Note: Don't clear HTTP cache here as it's shared across workspace tabs\n                \n            # Close tab\n            self.tab_widget.removeTab(index)\n            web_view.deleteLater()\n            \n            self.session_changed.emit()\n    \n    def new_tab(self):\n        \"\"\"Create a new tab\"\"\"\n        index = self.add_tab()\n        self.tab_widget.setCurrentIndex(index)\n    \n    def restore_last_closed_tab(self):\n        \"\"\"Restore the most recently closed tab\"\"\"\n        if self.closed_tabs:\n            tab_data = self.closed_tabs.pop()\n            index = self.add_tab(tab_data.url)\n            self.tab_widget.setCurrentIndex(index)\n    \n    def _on_tab_changed(self, index: int):\n        \"\"\"Handle tab change\"\"\"\n        self.workspace_data.active_tab = index\n        self.session_changed.emit()\n    \n    def get_session_data(self) -> WorkspaceData:\n        \"\"\"Get current session data for this workspace\"\"\"\n        tabs = []\n        for i in range(self.tab_widget.count()):\n            web_view = self.tab_widget.widget(i)\n            if isinstance(web_view, ChatGPTWebView):\n                tabs.append(TabData(\n                    url=web_view.url().toString(),\n                    title=self.tab_widget.tabText(i)\n                ))\n        \n        return WorkspaceData(\n            name=self.workspace_data.name,\n            tabs=tabs,\n            active_tab=self.tab_widget.currentIndex(),\n            notepad_content=self.workspace_data.notepad_content,\n            notepad_visible=self.workspace_data.notepad_visible\n        )\n    \n    def reload_current_tab(self):\n        \"\"\"Reload the current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.reload()\n    \n    def navigate_back(self):\n        \"\"\"Navigate back in current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.back()\n    \n    def navigate_forward(self):\n        \"\"\"Navigate forward in current tab\"\"\"\n        current_widget = self.tab_widget.currentWidget()\n        if isinstance(current_widget, ChatGPTWebView):\n            current_widget.forward()\n    \n    def cleanup(self):\n        \"\"\"Clean up resources\"\"\"\n        # Clear closed tabs to free memory\n        self.closed_tabs.clear()\n        \n        # Clean up web views\n        for web_view in self.web_views:\n            # Force cleanup of web engine resources\n            if hasattr(web_view, 'page_obj') and web_view.page_obj:\n                web_view.page_obj.deleteLater()\n            web_view.deleteLater()\n        self.web_views.clear()\n        \n        # Clean up profile resources\n        if hasattr(self, 'workspace_profile'):\n            self.workspace_profile.clearAllVisitedLinks()\n            self.workspace_profile.clearHttpCache()","size_bytes":28004},"src/ui/notifications.py":{"content":"\"\"\"\nSimple notification system for user feedback\n\"\"\"\n\nfrom PyQt6.QtWidgets import QWidget, QLabel, QVBoxLayout, QGraphicsDropShadowEffect\nfrom PyQt6.QtCore import QTimer, QPropertyAnimation, QEasingCurve, pyqtProperty, Qt\nfrom PyQt6.QtGui import QFont, QColor\nfrom ..config import COLORS\n\n\nclass NotificationWidget(QWidget):\n    \"\"\"Simple notification widget that slides in and auto-hides\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setFixedSize(350, 60)\n        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)\n        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)\n        self._opacity = 0.0\n        \n        self.setup_ui()\n        self.setup_style()\n        self.setup_animation()\n        \n        # Auto-hide timer\n        self.hide_timer = QTimer()\n        self.hide_timer.setSingleShot(True)\n        self.hide_timer.timeout.connect(self.hide_notification)\n    \n    def setup_ui(self):\n        \"\"\"Setup notification UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(15, 10, 15, 10)\n        \n        self.message_label = QLabel()\n        self.message_label.setFont(QFont(\"Arial\", 10))\n        self.message_label.setWordWrap(True)\n        self.message_label.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        layout.addWidget(self.message_label)\n    \n    def setup_style(self):\n        \"\"\"Apply notification styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {COLORS['secondary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 8px;\n            }}\n            QLabel {{\n                color: {COLORS['text']};\n                border: none;\n                background: transparent;\n            }}\n        \"\"\")\n        \n        # Add drop shadow\n        shadow = QGraphicsDropShadowEffect()\n        shadow.setBlurRadius(20)\n        shadow.setColor(QColor(0, 0, 0, 100))\n        shadow.setOffset(0, 3)\n        self.setGraphicsEffect(shadow)\n    \n    def setup_animation(self):\n        \"\"\"Setup fade in/out animation\"\"\"\n        self.animation = QPropertyAnimation(self, b\"opacity\")\n        self.animation.setDuration(300)\n        self.animation.setEasingCurve(QEasingCurve.Type.OutCubic)\n    \n    def get_opacity(self):\n        return self._opacity\n    \n    def set_opacity(self, value):\n        self._opacity = value\n        self.setWindowOpacity(value)\n    \n    opacity = pyqtProperty(float, get_opacity, set_opacity)\n    \n    def show_notification(self, message: str, duration: int = 3000):\n        \"\"\"Show notification with message\"\"\"\n        self.message_label.setText(message)\n        \n        # Position at top-right of parent\n        if self.parent():\n            parent_rect = self.parent().rect()\n            x = parent_rect.width() - self.width() - 20\n            y = 20\n            self.move(x, y)\n        \n        # Animate fade in\n        self.show()\n        try:\n            self.animation.finished.disconnect()  # Clear any previous connections\n        except TypeError:\n            pass  # No connections to disconnect\n        self.animation.setStartValue(0.0)\n        self.animation.setEndValue(0.9)\n        self.animation.start()\n        \n        # Set auto-hide timer\n        self.hide_timer.stop()\n        self.hide_timer.start(duration)\n    \n    def hide_notification(self):\n        \"\"\"Hide notification with fade out\"\"\"\n        try:\n            self.animation.finished.disconnect()\n        except TypeError:\n            pass  # No connections to disconnect\n        self.animation.finished.connect(self.hide)\n        self.animation.setStartValue(self.get_opacity())\n        self.animation.setEndValue(0.0)\n        self.animation.start()\n\n\nclass StatusIndicator(QWidget):\n    \"\"\"Simple status indicator for startup progress\"\"\"\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setFixedHeight(30)\n        self.setup_ui()\n        self.setup_style()\n    \n    def setup_ui(self):\n        \"\"\"Setup status indicator UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setContentsMargins(10, 5, 10, 5)\n        \n        self.status_label = QLabel(\"Initializing...\")\n        self.status_label.setFont(QFont(\"Arial\", 9))\n        self.status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)\n        layout.addWidget(self.status_label)\n    \n    def setup_style(self):\n        \"\"\"Apply status indicator styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {COLORS['primary_bg']};\n                border-bottom: 1px solid {COLORS['accent']};\n            }}\n            QLabel {{\n                color: {COLORS['text_dim']};\n                border: none;\n                background: transparent;\n            }}\n        \"\"\")\n    \n    def set_status(self, status: str):\n        \"\"\"Update status message\"\"\"\n        self.status_label.setText(status)\n    \n    def hide_status(self):\n        \"\"\"Hide status indicator\"\"\"\n        self.hide()","size_bytes":5036},"src/web/oauth_handler.py":{"content":"\"\"\"\nLightweight OAuth handler for redirecting authentication to system browser\n\"\"\"\n\nimport webbrowser\nfrom typing import Optional\nfrom urllib.parse import urlparse\nfrom PyQt6.QtCore import QObject, pyqtSignal, QUrl\nfrom PyQt6.QtGui import QDesktopServices\n\n\nclass OAuthHandler(QObject):\n    \"\"\"Minimal OAuth detection and redirection handler\"\"\"\n    \n# OAuth notifications removed\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # OAuth patterns that should be redirected to system browser\n        self.oauth_patterns = [\n            'accounts.google.com',\n            'oauth2.googleapis.com',\n            'accounts.youtube.com',\n            'myaccount.google.com/oauth',\n            'oauth.googleusercontent.com'\n        ]\n    \n    def should_redirect_to_system_browser(self, url: str) -> bool:\n        \"\"\"\n        Check if URL should be redirected to system browser for OAuth\n        \n        For ChatGPT/OpenAI authentication flows, we keep Google OAuth within the app\n        to maintain session continuity. This prevents the \"invalid session\" error\n        that occurs when OAuth callbacks try to return to a different browser context.\n        \n        Args:\n            url: The URL to check\n            \n        Returns:\n            True if URL should be redirected to system browser\n        \"\"\"\n        # IMPORTANT: For this ChatGPT Browser app, we disable OAuth redirection\n        # to system browser entirely. This ensures that Google OAuth flows for\n        # ChatGPT/OpenAI authentication stay within the same browser context,\n        # preventing session mismatch errors.\n        #\n        # The original OAuth redirection was causing \"Route Error (400 Invalid Session)\"\n        # because the OAuth session was initiated in the embedded WebView but\n        # callbacks were landing in the external system browser, breaking the flow.\n        \n        return False\n    \n    def redirect_to_system_browser(self, url: str) -> bool:\n        \"\"\"\n        Redirect OAuth URL to system browser\n        \n        Args:\n            url: The URL to redirect\n            \n        Returns:\n            True if redirect was successful\n        \"\"\"\n        try:\n            # Use Qt's desktop services for reliable opening\n            qurl = QUrl(url)\n            success = QDesktopServices.openUrl(qurl)\n            \n            if success:\n                return True\n            else:\n                # Fallback to Python webbrowser module\n                webbrowser.open(url, new=2)  # new=2 opens in new tab\n                return True\n                \n        except Exception as e:\n            # If both methods fail, let the navigation continue normally\n            return False\n    \n    def handle_navigation_request(self, url: str) -> bool:\n        \"\"\"\n        Handle navigation request and redirect OAuth if needed\n        \n        Args:\n            url: The requested navigation URL\n            \n        Returns:\n            True if navigation was handled (redirected), False to continue normally\n        \"\"\"\n        if self.should_redirect_to_system_browser(url):\n            return self.redirect_to_system_browser(url)\n        return False","size_bytes":3192},"src/web/security_interceptor.py":{"content":"\"\"\"\nEnhanced security interceptor with domain allowlist and user warnings\n\"\"\"\n\nimport json\nimport os\nfrom typing import Set, Optional, Tuple\nfrom urllib.parse import urlparse\nfrom PyQt6.QtCore import QObject, pyqtSignal\n\nfrom ..paths import get_app_data_dir\n\n\nclass DomainAllowlistManager:\n    \"\"\"Manages the domain allowlist with persistent storage\"\"\"\n    \n    def __init__(self):\n        self.allowlist_file = get_app_data_dir() / \"domain_allowlist.json\"\n        self.allowed_domains: Set[str] = set()\n        self.load_allowlist()\n        self._ensure_default_domains()\n    \n    def _ensure_default_domains(self):\n        \"\"\"Ensure default domains are always in the allowlist\"\"\"\n        default_domains = {\n            'chatgpt.com',\n            'openai.com',\n            'auth0.openai.com',\n            'cdn.openai.com', \n            'static.openai.com',\n            'api.openai.com',\n            'accounts.google.com',  # For Google OAuth\n            'googleapis.com',       # For Google services\n            'gstatic.com',         # For Google static assets\n            'fonts.googleapis.com', # For Google fonts\n            'fonts.gstatic.com',   # For Google fonts\n            'sentry.io',           # If error reporting is used\n            'cloudflare.com',      # CDN that ChatGPT might use\n            'azureedge.net',       # Azure CDN that OpenAI uses\n        }\n        \n        changed = False\n        for domain in default_domains:\n            if domain not in self.allowed_domains:\n                self.allowed_domains.add(domain)\n                changed = True\n        \n        if changed:\n            self.save_allowlist()\n    \n    def load_allowlist(self):\n        \"\"\"Load allowlist from disk\"\"\"\n        try:\n            if self.allowlist_file.exists():\n                with open(self.allowlist_file, 'r') as f:\n                    data = json.load(f)\n                    self.allowed_domains = set(data.get('domains', []))\n        except Exception:\n            # If loading fails, start with empty allowlist\n            self.allowed_domains = set()\n    \n    def save_allowlist(self):\n        \"\"\"Save allowlist to disk\"\"\"\n        try:\n            self.allowlist_file.parent.mkdir(parents=True, exist_ok=True)\n            with open(self.allowlist_file, 'w') as f:\n                json.dump({'domains': list(self.allowed_domains)}, f, indent=2)\n        except Exception:\n            # If saving fails, continue silently\n            pass\n    \n    def add_domain(self, domain: str):\n        \"\"\"Add a domain to the allowlist\"\"\"\n        domain = domain.lower().strip()\n        if domain and domain not in self.allowed_domains:\n            self.allowed_domains.add(domain)\n            self.save_allowlist()\n    \n    def is_domain_allowed(self, url: str) -> bool:\n        \"\"\"\n        Check if a domain is allowed (including subdomains)\n        \n        Args:\n            url: The URL to check\n            \n        Returns:\n            True if domain is allowed\n        \"\"\"\n        try:\n            parsed = urlparse(url)\n            domain = parsed.netloc.lower()\n            \n            # Remove port if present\n            if ':' in domain:\n                domain = domain.split(':')[0]\n            \n            # Check exact match first\n            if domain in self.allowed_domains:\n                return True\n            \n            # Check if it's a subdomain of an allowed domain\n            for allowed_domain in self.allowed_domains:\n                if domain.endswith('.' + allowed_domain):\n                    return True\n            \n            return False\n            \n        except Exception:\n            return False\n\n\nclass SecurityInterceptor(QObject):\n    \"\"\"Enhanced security interceptor with domain allowlist and warnings\"\"\"\n    \n    # Signal emitted when user needs to make a decision about a blocked domain\n    domain_decision_needed = pyqtSignal(str, str)  # url, domain\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # Domain allowlist manager\n        self.allowlist_manager = DomainAllowlistManager()\n        \n        # Use positive allowlist for schemes (more secure)\n        self.allowed_schemes: Set[str] = {\n            'http',\n            'https',\n            'about'  # We'll handle about:blank specially\n        }\n        \n        # Track temporary one-time allowances for this session\n        self.session_allowed_domains: Set[str] = set()\n    \n    def should_block_url(self, url: str) -> Tuple[bool, str]:\n        \"\"\"\n        Check if URL should be blocked\n        \n        Args:\n            url: The URL to check\n            \n        Returns:\n            (should_block, reason) - reason is empty if not blocked\n        \"\"\"\n        if not url:\n            return True, \"Empty URL\"\n            \n        try:\n            # Check schemes with positive allowlist (more secure)\n            if ':' in url:\n                scheme = url.split(':', 1)[0].lower().strip()\n                \n                if scheme not in self.allowed_schemes:\n                    return True, f\"Scheme '{scheme}' not allowed\"\n                \n                # Special case: only allow about:blank, block other about: pages\n                if scheme == 'about':\n                    if not url.lower().strip().startswith('about:blank'):\n                        return True, \"Internal pages blocked for security\"\n            \n            # Check domain allowlist\n            parsed = urlparse(url)\n            domain = parsed.netloc.lower()\n            \n            # Remove port if present\n            if ':' in domain:\n                domain = domain.split(':')[0]\n            \n            # Allow if domain is permanently allowed\n            if self.allowlist_manager.is_domain_allowed(url):\n                return False, \"\"\n            \n            # Allow if domain is temporarily allowed for this session\n            for session_domain in self.session_allowed_domains:\n                if domain == session_domain or domain.endswith('.' + session_domain):\n                    return False, \"\"\n            \n            # Block unknown domain (will trigger warning)\n            return True, f\"Domain '{domain}' not in allowlist\"\n                \n        except Exception as e:\n            # If URL parsing fails, block it\n            return True, f\"Invalid URL format: {str(e)}\"\n    \n    def add_domain_to_allowlist(self, domain: str):\n        \"\"\"Add domain to permanent allowlist\"\"\"\n        self.allowlist_manager.add_domain(domain)\n    \n    def allow_domain_once(self, domain: str):\n        \"\"\"Allow domain for this session only\"\"\"\n        domain = domain.lower().strip()\n        if domain:\n            self.session_allowed_domains.add(domain)\n    \n    def get_domain_from_url(self, url: str) -> str:\n        \"\"\"Extract domain from URL\"\"\"\n        try:\n            parsed = urlparse(url)\n            domain = parsed.netloc.lower()\n            # Remove port if present\n            if ':' in domain:\n                domain = domain.split(':')[0]\n            return domain\n        except Exception:\n            return \"\"","size_bytes":7089},"src/ui/animated_widgets.py":{"content":"\"\"\"\nAnimated widgets for smooth transitions\n\"\"\"\n\nfrom PyQt6.QtWidgets import QStackedWidget, QWidget, QGraphicsOpacityEffect, QSplitter\nfrom PyQt6.QtCore import QPropertyAnimation, QEasingCurve, pyqtSignal, QTimer, QObject, QVariantAnimation\n\n\nclass AnimatedStackedWidget(QStackedWidget):\n    \"\"\"QStackedWidget with crossfade animation between pages\"\"\"\n    \n    animation_finished = pyqtSignal()\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.animation_duration = 250  # 250ms as requested\n        self.current_animation = None\n        self.next_index = -1\n        self.preload_timer = QTimer()\n        self.preload_timer.setSingleShot(True)\n        self.preload_timer.timeout.connect(self._start_animation)\n        \n    def setCurrentIndexAnimated(self, index: int):\n        \"\"\"Switch to index with crossfade animation\"\"\"\n        if index == self.currentIndex() or index < 0 or index >= self.count():\n            return\n            \n        # Store the target index\n        self.next_index = index\n        \n        # Start preloading immediately (this gives time for workspace to load)\n        self.preload_timer.start(0)  # Start immediately but allows other operations\n        \n    def _start_animation(self):\n        \"\"\"Start the crossfade animation\"\"\"\n        if self.next_index == -1 or self.current_animation:\n            return\n            \n        current_widget = self.currentWidget()\n        next_widget = self.widget(self.next_index)\n        \n        if not current_widget or not next_widget:\n            self.setCurrentIndex(self.next_index)\n            self.next_index = -1\n            return\n        \n        # Create opacity effects\n        current_effect = QGraphicsOpacityEffect()\n        next_effect = QGraphicsOpacityEffect()\n        \n        current_widget.setGraphicsEffect(current_effect)\n        next_widget.setGraphicsEffect(next_effect)\n        \n        # Set initial opacity values\n        current_effect.setOpacity(1.0)\n        next_effect.setOpacity(0.0)\n        \n        # Make next widget visible and on top\n        next_widget.show()\n        next_widget.raise_()\n        \n        # Create animations\n        self.fade_out_animation = QPropertyAnimation(current_effect, b\"opacity\")\n        self.fade_out_animation.setDuration(self.animation_duration)\n        self.fade_out_animation.setStartValue(1.0)\n        self.fade_out_animation.setEndValue(0.0)\n        self.fade_out_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)\n        \n        self.fade_in_animation = QPropertyAnimation(next_effect, b\"opacity\")\n        self.fade_in_animation.setDuration(self.animation_duration)\n        self.fade_in_animation.setStartValue(0.0)\n        self.fade_in_animation.setEndValue(1.0)\n        self.fade_in_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)\n        \n        # Connect animation finished\n        self.fade_in_animation.finished.connect(self._animation_finished)\n        \n        # Set current animation reference\n        self.current_animation = self.fade_in_animation\n        \n        # Start animations\n        self.fade_out_animation.start()\n        self.fade_in_animation.start()\n        \n        # Don't switch index immediately - wait for animation to complete\n        \n    def _animation_finished(self):\n        \"\"\"Clean up after animation completes\"\"\"\n        if self.current_animation:\n            # Now switch to the target index\n            target_index = self.next_index\n            super().setCurrentIndex(target_index)\n            \n            # Remove opacity effects from all widgets\n            for i in range(self.count()):\n                widget = self.widget(i)\n                if widget:\n                    widget.setGraphicsEffect(None)\n            \n            self.current_animation = None\n            self.next_index = -1\n            self.animation_finished.emit()\n            \n    def setCurrentIndex(self, index: int):\n        \"\"\"Override to use animated version by default\"\"\"\n        if hasattr(self, 'animation_duration'):  # Check if fully initialized\n            self.setCurrentIndexAnimated(index)\n        else:\n            super().setCurrentIndex(index)\n\n\nclass SplitterAnimator(QObject):\n    \"\"\"Handles smooth animation of QSplitter sizes\"\"\"\n    \n    animation_finished = pyqtSignal()\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.animation = None\n        self.current_splitter = None\n        self.start_sizes = []\n        self.end_sizes = []\n        \n    def animate_to_sizes(self, splitter: QSplitter, target_sizes: list, duration: int = 140):\n        \"\"\"Animate splitter to target sizes\"\"\"\n        if not splitter or self.animation:\n            return\n            \n        # Get current sizes\n        current_sizes = splitter.sizes()\n        if len(current_sizes) != len(target_sizes):\n            # Fallback to instant change if sizes don't match\n            splitter.setSizes(target_sizes)\n            self.animation_finished.emit()\n            return\n        \n        # Store references for the animation\n        self.current_splitter = splitter\n        self.start_sizes = current_sizes[:]\n        self.end_sizes = target_sizes[:]\n        \n        # Create variant animation that goes from 0 to 1\n        self.animation = QVariantAnimation(self)\n        self.animation.setStartValue(0.0)\n        self.animation.setEndValue(1.0)\n        self.animation.setDuration(duration)\n        self.animation.setEasingCurve(QEasingCurve.Type.InOutCubic)\n        \n        # Connect value change to our interpolation method\n        self.animation.valueChanged.connect(self._update_splitter_sizes)\n        self.animation.finished.connect(self._on_animation_finished)\n        \n        # Start animation\n        self.animation.start()\n    \n    def _update_splitter_sizes(self, progress):\n        \"\"\"Update splitter sizes based on animation progress\"\"\"\n        if not self.current_splitter:\n            return\n            \n        # Interpolate between start and end sizes\n        current_sizes = []\n        for start, end in zip(self.start_sizes, self.end_sizes):\n            interpolated = start + (end - start) * progress\n            current_sizes.append(int(interpolated))\n        \n        self.current_splitter.setSizes(current_sizes)\n        \n    def _on_animation_finished(self):\n        \"\"\"Clean up after animation\"\"\"\n        # Ensure final sizes are set exactly\n        if self.current_splitter and self.end_sizes:\n            self.current_splitter.setSizes(self.end_sizes)\n            \n        self.animation = None\n        self.current_splitter = None\n        self.start_sizes = []\n        self.end_sizes = []\n        self.animation_finished.emit()","size_bytes":6709},"src/ui/memory_manager.py":{"content":"\"\"\"\nIntelligent memory management for workspaces and tabs\n\"\"\"\n\nimport time\nfrom typing import Dict, Set, Optional\nfrom PyQt6.QtCore import QObject, QTimer, pyqtSignal, QUrl\nfrom PyQt6.QtWebEngineWidgets import QWebEngineView\n\n# Configuration\nCOMPRESSION_DELAY_MINUTES = 5  # Compress after 5 minutes of inactivity\nCHECK_INTERVAL_MS = 60000  # Check every minute\n\n\nclass MemoryManager(QObject):\n    \"\"\"Manages memory usage of workspaces and tabs with intelligent compression\"\"\"\n    \n    workspace_needs_loading = pyqtSignal(int)  # workspace_id\n    \n    def __init__(self, parent=None):\n        super().__init__(parent)\n        \n        # Track usage timestamps for workspaces and tabs\n        self.workspace_last_used: Dict[int, float] = {}\n        self.tab_last_used: Dict[str, float] = {}  # \"workspace_id:tab_index\" format\n        \n        # Track compressed state\n        self.compressed_workspaces: Set[int] = set()\n        self.compressed_tabs: Set[str] = set()\n        \n        # Setup cleanup timer\n        self.cleanup_timer = QTimer(self)\n        self.cleanup_timer.timeout.connect(self._cleanup_unused_memory)\n        self.cleanup_timer.start(CHECK_INTERVAL_MS)\n    \n    def mark_workspace_used(self, workspace_id: int):\n        \"\"\"Mark a workspace as recently used\"\"\"\n        self.workspace_last_used[workspace_id] = time.time()\n        \n        # If workspace was compressed, mark it for loading\n        if workspace_id in self.compressed_workspaces:\n            self.compressed_workspaces.remove(workspace_id)\n            self.workspace_needs_loading.emit(workspace_id)\n    \n    def mark_tab_used(self, workspace_id: int, tab_index: int):\n        \"\"\"Mark a specific tab as recently used\"\"\"\n        tab_key = f\"{workspace_id}:{tab_index}\"\n        self.tab_last_used[tab_key] = time.time()\n        \n        # If tab was compressed, remove from compressed set\n        self.compressed_tabs.discard(tab_key)\n    \n    def is_workspace_compressed(self, workspace_id: int) -> bool:\n        \"\"\"Check if a workspace is currently compressed\"\"\"\n        return workspace_id in self.compressed_workspaces\n    \n    def is_tab_compressed(self, workspace_id: int, tab_index: int) -> bool:\n        \"\"\"Check if a tab is currently compressed\"\"\"\n        tab_key = f\"{workspace_id}:{tab_index}\"\n        return tab_key in self.compressed_tabs\n    \n    def compress_workspace(self, workspace_id: int, workspace_widget):\n        \"\"\"Compress a workspace by suspending web views\"\"\"\n        if workspace_id in self.compressed_workspaces:\n            return\n            \n        # Suspend all tabs in this workspace\n        tab_widget = workspace_widget.tab_widget\n        for i in range(tab_widget.count()):\n            web_view = tab_widget.widget(i)\n            if isinstance(web_view, QWebEngineView):\n                # Store the URL and clear the page to free memory\n                current_url = web_view.url().toString()\n                if hasattr(web_view, '_original_url'):\n                    web_view._original_url = current_url\n                else:\n                    web_view._original_url = current_url\n                \n                # Navigate to about:blank to free memory\n                web_view.setUrl(QUrl(\"about:blank\"))\n        \n        self.compressed_workspaces.add(workspace_id)\n    \n    def restore_workspace(self, workspace_id: int, workspace_widget):\n        \"\"\"Restore a compressed workspace\"\"\"\n        if workspace_id not in self.compressed_workspaces:\n            return\n            \n        # Restore all tabs in this workspace\n        tab_widget = workspace_widget.tab_widget\n        for i in range(tab_widget.count()):\n            web_view = tab_widget.widget(i)\n            if isinstance(web_view, QWebEngineView) and hasattr(web_view, '_original_url'):\n                # Restore the original URL\n                web_view.setUrl(QUrl(web_view._original_url))\n        \n        self.compressed_workspaces.remove(workspace_id)\n    \n    def _cleanup_unused_memory(self):\n        \"\"\"Check for unused workspaces/tabs and compress them\"\"\"\n        current_time = time.time()\n        threshold_seconds = COMPRESSION_DELAY_MINUTES * 60\n        \n        # Find workspaces that haven't been used recently\n        workspaces_to_compress = []\n        for workspace_id, last_used in self.workspace_last_used.items():\n            if current_time - last_used > threshold_seconds:\n                if workspace_id not in self.compressed_workspaces:\n                    workspaces_to_compress.append(workspace_id)\n        \n        # Emit signals for workspaces that need compression\n        # The main window will handle the actual compression\n        for workspace_id in workspaces_to_compress:\n            self.compress_workspace_signal.emit(workspace_id)\n    \n    # Signal for main window to handle compression\n    compress_workspace_signal = pyqtSignal(int)","size_bytes":4865},"src/ui/security_dialog.py":{"content":"\"\"\"\nSecurity warning dialog for domain access\n\"\"\"\n\nfrom PyQt6.QtWidgets import (\n    QDialog, QVBoxLayout, QHBoxLayout, QLabel, \n    QPushButton, QFrame\n)\nfrom PyQt6.QtCore import Qt\nfrom PyQt6.QtGui import QFont, QIcon\n\nfrom ..config import COLORS\n\n\nclass DomainWarningDialog(QDialog):\n    \"\"\"Warning dialog for accessing non-whitelisted domains\"\"\"\n    \n    ALLOW_ONCE = 1\n    ADD_TO_ALLOWLIST = 2 \n    CANCEL = 0\n    \n    def __init__(self, url: str, domain: str, parent=None):\n        super().__init__(parent)\n        self.url = url\n        self.domain = domain\n        self.result_choice = self.CANCEL\n        \n        self.setWindowTitle(\"Website Security Warning\")\n        self.setModal(True)\n        self.setFixedSize(500, 280)\n        \n        self.setup_ui()\n        self.setup_style()\n        \n    def setup_ui(self):\n        \"\"\"Setup dialog UI\"\"\"\n        layout = QVBoxLayout(self)\n        layout.setSpacing(15)\n        layout.setContentsMargins(20, 20, 20, 20)\n        \n        # Warning icon and title\n        title_layout = QHBoxLayout()\n        \n        # Warning title\n        title_label = QLabel(\"⚠️ Unknown Website\")\n        title_label.setFont(QFont(\"Arial\", 14, QFont.Weight.Bold))\n        title_layout.addWidget(title_label)\n        title_layout.addStretch()\n        \n        layout.addLayout(title_layout)\n        \n        # Message\n        message = QLabel(\n            f\"You're trying to visit a website that's not on your approved list:\\n\\n\"\n            f\"🌐 <b>{self.domain}</b>\\n\\n\"\n            f\"This browser is designed to keep you safe by only allowing trusted websites. \"\n            f\"What would you like to do?\"\n        )\n        message.setWordWrap(True)\n        message.setFont(QFont(\"Arial\", 10))\n        layout.addWidget(message)\n        \n        # URL display (truncated if too long)\n        url_display = self.url\n        if len(url_display) > 70:\n            url_display = url_display[:67] + \"...\"\n        \n        url_label = QLabel(f\"Full URL: {url_display}\")\n        url_label.setFont(QFont(\"Arial\", 9))\n        url_label.setStyleSheet(f\"color: {COLORS['text_dim']}; padding: 5px;\")\n        layout.addWidget(url_label)\n        \n        # Separator line\n        line = QFrame()\n        line.setFrameShape(QFrame.Shape.HLine)\n        line.setFrameShadow(QFrame.Shadow.Sunken)\n        layout.addWidget(line)\n        \n        # Button layout\n        button_layout = QHBoxLayout()\n        button_layout.setSpacing(10)\n        \n        # Cancel button\n        cancel_btn = QPushButton(\"🚫 Cancel\")\n        cancel_btn.setFont(QFont(\"Arial\", 10))\n        cancel_btn.clicked.connect(lambda: self.choose_option(self.CANCEL))\n        button_layout.addWidget(cancel_btn)\n        \n        button_layout.addStretch()\n        \n        # Allow once button\n        allow_once_btn = QPushButton(\"👁️ Allow Once\")\n        allow_once_btn.setFont(QFont(\"Arial\", 10))\n        allow_once_btn.clicked.connect(lambda: self.choose_option(self.ALLOW_ONCE))\n        button_layout.addWidget(allow_once_btn)\n        \n        # Add to allowlist button\n        add_btn = QPushButton(\"✅ Always Allow\")\n        add_btn.setFont(QFont(\"Arial\", 10, QFont.Weight.Bold))\n        add_btn.clicked.connect(lambda: self.choose_option(self.ADD_TO_ALLOWLIST))\n        button_layout.addWidget(add_btn)\n        \n        layout.addLayout(button_layout)\n        \n        # Explanation text\n        explanation = QLabel(\n            \"• 'Cancel' - Stay on the current page\\n\"\n            \"• 'Allow Once' - Visit this time only\\n\"\n            f\"• 'Always Allow' - Add '{self.domain}' to your trusted sites\"\n        )\n        explanation.setFont(QFont(\"Arial\", 8))\n        explanation.setStyleSheet(f\"color: {COLORS['text_dim']}; padding: 5px;\")\n        layout.addWidget(explanation)\n        \n    def setup_style(self):\n        \"\"\"Apply dark theme styling\"\"\"\n        self.setStyleSheet(f\"\"\"\n            QDialog {{\n                background-color: {COLORS['primary_bg']};\n                color: {COLORS['text']};\n                border: 2px solid {COLORS['accent']};\n            }}\n            QLabel {{\n                color: {COLORS['text']};\n                background: transparent;\n            }}\n            QPushButton {{\n                background-color: {COLORS['secondary_bg']};\n                border: 1px solid {COLORS['accent']};\n                border-radius: 6px;\n                padding: 8px 16px;\n                color: {COLORS['text']};\n                min-width: 100px;\n            }}\n            QPushButton:hover {{\n                background-color: {COLORS['accent']};\n                border-color: #555;\n            }}\n            QPushButton:pressed {{\n                background-color: #222;\n            }}\n            QFrame {{\n                color: {COLORS['accent']};\n            }}\n        \"\"\")\n        \n    def choose_option(self, choice: int):\n        \"\"\"Handle user choice\"\"\"\n        self.result_choice = choice\n        if choice == self.CANCEL:\n            self.reject()\n        else:\n            self.accept()\n    \n    def get_choice(self) -> int:\n        \"\"\"Get the user's choice\"\"\"\n        return self.result_choice","size_bytes":5162}},"version":1}